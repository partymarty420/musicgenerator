<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Random Music Studio v7.7 â€”by Party Marty</title>
<style>
  :root{ --bg:#0a0f14; --panel:#111827; --ink:#e6edf3; --muted:#9fb0c3; --accent:#7dd3fc; --accent2:#a78bfa; --good:#86efac; --warn:#fbbf24 }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:radial-gradient(900px 600px at 90% -20%,#1b2430 0%, #0a0f14 50%) fixed;color:var(--ink)}
  header{padding:16px 18px;border-bottom:1px solid #1f2937;background:linear-gradient(180deg,#121826 0%,#0d1420 100%)}
  h1{margin:0;font-size:18px;letter-spacing:.2px}
  main{display:grid;grid-template-columns:460px 1fr;gap:16px;padding:16px}
  @media(max-width:1200px){main{grid-template-columns:1fr}}
  .panel{background:var(--panel);border:1px solid #1f2937;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .controls{padding:16px;display:grid;gap:14px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .row label{font-size:12px;color:var(--muted);min-width:72px}
  .row input[type=range]{width:150px}
  fieldset{border:1px solid #233143;border-radius:12px;padding:12px}
  legend{padding:0 6px;color:var(--muted);font-size:12px}
  button{appearance:none;border:none;background:#1a2232;color:var(--ink);padding:9px 12px;border-radius:12px;cursor:pointer;font-weight:600;box-shadow:0 2px 0 #0a0d14;transition:transform .05s ease, background .2s ease}
  button:hover{background:#202a3c}
  button:active{transform:translateY(1px)}
  .primary{background:linear-gradient(180deg,#22d3ee,#0ea5e9);color:#001218;box-shadow:0 2px 0 #075985}
  .danger{background:linear-gradient(180deg,#ef4444,#dc2626);color:#fff}
  .good{background:linear-gradient(180deg,#34d399,#10b981);color:#02150e}
  select,input[type=number],.pill,input[type=text]{background:#0f1520;border:1px solid #233143;color:var(--ink);border-radius:10px;padding:8px 10px}
  .mutetext{color:var(--muted);font-size:12px}
  .meter{height:8px;background:#0f172a;border-radius:999px;overflow:hidden;border:1px solid #1e293b}
  .bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--accent2));transition:width .08s}
  .grid{display:grid;grid-template-columns:repeat(16,1fr);gap:4px}
  .cell{height:28px;border-radius:6px;background:#0c1320;border:1px solid #1c2941;cursor:pointer}
  .cell.on{background:linear-gradient(180deg,#22d3ee33,#a78bfa33);border-color:#3a4f74;box-shadow:inset 0 0 10px #7dd3fc55}
  .workspace{padding:16px;display:grid;gap:16px}
  .lane{display:grid;grid-template-columns:150px 1fr;gap:10px;align-items:center}
  .lane .lane-ctrls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .tag{font-size:11px;color:#a3b6cd;background:#0f172a;border:1px solid #1f2a44;border-radius:999px;padding:2px 8px}
  .led{width:10px;height:10px;border-radius:50%;background:#111827;box-shadow:0 0 8px #000 inset;border:1px solid #1f2937}
  .led.on{background:#10b981;box-shadow:0 0 10px #10b981}
  .kbd-wrap{background:#0b1220;border:1px solid #1f2a44;border-radius:14px;padding:12px}
  .keys{display:flex;position:relative;height:140px}
  .white{width:36px;height:100%;background:#fefefe;border:1px solid #c9d2e0;border-bottom-left-radius:6px;border-bottom-right-radius:6px;position:relative;z-index:1;cursor:pointer}
  .white:active{background:#e7f3ff}
  .black{position:absolute;width:24px;height:84px;background:#151c28;border:1px solid #2b3a57;border-radius:4px;z-index:2;margin-left:-12px;left:27px;cursor:pointer}
  .black:active{background:#26334d}
  .keyname{position:absolute;bottom:6px;left:0;right:0;text-align:center;font-size:10px;color:#334155}
  .kb-row{display:flex;gap:8px;align-items:center;margin-top:8px}
  .pill.small{font-size:11px;padding:4px 8px}
  .hidden{display:none}
  .list{padding:8px;border:1px dashed #2a3a56;border-radius:10px;max-height:160px;overflow:auto;background:#0e1522}
  .list-item{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-bottom:1px dashed #1e2a44}
  .list-item:last-child{border-bottom:none}
  @media(max-width:720px){
    .row label{min-width:60px}
    .row input[type=range]{width:120px}
    .white{width:28px}
    .black{width:18px;height:68px;left:22px}
    main{padding:10px}
  }

  body.env-disabled fieldset legend:contains('Envelope'),
  body.env-disabled .env-section label,
  body.env-disabled .env-section input,
  body.env-disabled .env-section select { opacity: 0.65; pointer-events: none; }

</style>
</head>
<body>
<header>
  <h1>ğŸ¹ Random Music Studio v7.7 â€¢ by Party Marty</h1>
</header>
<main>
  <section class="panel controls">
    <!-- Transport -->
    <div class="row">
      <button id="startBtn" class="primary">â–¶ï¸ Start</button>
      <button id="stopBtn" class="danger">â¹ Stop</button>
      <button id="rndAll" class="good">âœ¨ Randomize All</button>
      <button id="qaToggle">âš¡ Quick Actions</button>
      <span class="spacer"></span>
      <span class="mutetext">CPU</span>
      <div class="meter" style="width:140px"><div class="bar" id="cpubar"></div></div>
    </div>
    <div id="qaTransport" class="row hidden" style="gap:6px">
      <label>QA</label>
      <button id="tRndDrums">ğŸ² Dr</button>
      <button id="tClrDrums">ğŸ§¹ Dr</button>
      <button id="tRndMel">ğŸ² Mel</button>
      <button id="tClrMel">ğŸ§¹ Mel</button>
      <button id="tRndBass">ğŸ² Bs</button>
            <button id="tNextBass">ğŸ›ï¸ Bs</button>
      <button id="tClrBass">ğŸ§¹ Bs</button>
    </div>

    <!-- Master & Recording -->
    <fieldset>
      <legend>Master & Recording</legend>
      <div class="row">
        <label>Master</label><input id="master" type="range" min="0" max="1" step="0.01" value="0.85"/><span id="masterVal" class="pill">0.85</span>
        <div class="spacer"></div><div class="led" id="beatLED"></div><span class="mutetext">Beat</span>
      </div>
      <div class="row">
        <label>Format</label>
        <select id="recFmt"><option value="webm" selected>WebM (Opus)</option><option value="wav">WAV (PCM)</option><option value="mp3">MP3 (beta)</option></select>
        <button id="recBtn">âºï¸ Record</button>
        <a id="dl" class="mutetext" style="display:none">Download last take</a>
      </div>
    </fieldset>

    <!-- Randomizer -->
    <fieldset>
      \1
  <div class="row">
    <label class="mutetext">
      <input id="autoLastBarImprov" type="checkbox"/>
      randomize last bar
    </label>
    
  </div>

      <div class="row">
        <label>Enable</label><input id="autoOn" type="checkbox"/>
        <label>Change every</label>
        <select id="autoMeasures"><option value="1">1 bar</option><option value="2" selected>2 bars</option><option value="4">4 bars</option><option value="8">8 bars</option><option value="16">16 bars</option></select>
      </div>
      <div class="row">
        <label class="mutetext"><input id="autoMel" type="checkbox" checked/> Melody</label>
        <label class="mutetext"><input id="autoDrums" type="checkbox" checked/> Beat patterns</label>
        <label class="mutetext"><input id="autoBass" type="checkbox"/> Bassline</label>
        <label class="mutetext"><input id="autoChords" type="checkbox"/> Chords</label>
        <label class="mutetext"><input id="autoKit" type="checkbox"/> Drum types</label>
        <label class="mutetext"><input id="autoInst" type="checkbox"/> Lead instrument</label>
        <label class="mutetext"><input id="autoVoicing" type="checkbox"/> Voicing</label>
        <label class="mutetext"><input id="autoKeyScale" type="checkbox"/> Key/Scale</label>
      
        <label class="mutetext"><input id="autoMelB" type="checkbox"/> Lead B</label>
        <label class="mutetext"><input id="autoDrums2" type="checkbox"/> Drums 2</label>
</div>
      <div class="row">
        <label class="mutetext"><input id="autoTempo" type="checkbox"/> Tempo</label>
        <label>Î” BPM Â±</label><input id="autoTempoDelta" type="range" min="2" max="30" step="1" value="8"/><span id="autoTempoDeltaVal" class="pill">Â±8</span>
        <span class="pill small" id="autoStatus">Off</span>
      </div>

      <!-- FX Randomizer master switch -->
      <div class="row">
        <label>FX Randomizer</label>
        <input id="autoFXOn" type="checkbox" checked/>
        <span class="mutetext">Enable FX/Gate changes</span>
      </div>

      <!-- FX/Gate selections (Gate moved inline after Bitcrush) -->
      <div class="row">
        <label>FX</label>
        <label class="mutetext"><input id="autoFXDelay" type="checkbox" checked/> Delay</label>
        <label class="mutetext"><input id="autoFXReverb" type="checkbox" checked/> Reverb</label>
        <label class="mutetext"><input id="autoFXChorus" type="checkbox" checked/> Chorus</label>
        <label class="mutetext"><input id="autoFXPhaser" type="checkbox" checked/> Phaser</label>
        <label class="mutetext"><input id="autoFXBit" type="checkbox"/> Bitcrush</label>
        <label class="mutetext"><input id="autoGate" type="checkbox" checked/> Randomize Lead Gate</label>
      </div>
      <!-- Î” sliders split across two lines -->
      <div class="row">
        <label>Î” FX mix Â±</label><input id="autoFxDelta" type="range" min="0.02" max="0.6" step="0.01" value="0.18"/><span id="autoFxDeltaVal" class="pill">Â±0.18</span>
      </div>
      <div class="row">
        <label>Î” Gate Â±</label><input id="autoGateDelta" type="range" min="0.01" max="0.4" step="0.01" value="0.10"/><span id="autoGateDeltaVal" class="pill">Â±0.10</span>
      </div>
      <div class="row">
        <label class="mutetext"><input id="autoEnvNudge" type="checkbox"/> Envelope nudge</label>
        <span class="mutetext">Small jitters to cutoff & ADSR</span>
      </div>
      <div class="row">
        <label class="mutetext"><input id="envEnable" type="checkbox" checked/> Envelope enabled</label>
      </div>

      <!-- Switch Instrument / Hold Pattern -->
      <div class="row">
        <label></label>
        <button id="nextInst">ğŸ›ï¸ Switch Instrument</button>
                <button id="nextBass">ğŸ›ï¸ Switch Bass</button>
        <button id="holdBtn">â¸ï¸ Hold Pattern</button>
      </div>

      <!-- Quick Actions -->
      <div class="row">
        <label>Quick Actions</label>
      </div>
      <div class="row">
        <label></label>
        <button id="qaRndDrums">ğŸ² Randomize Drums</button>
        <button id="qaClrDrums">ğŸ§¹ Clear Drums</button>
        <button id="qaSwitchDrums">ğŸ›ï¸ Switch Drums</button>
      </div>
      <div class="row">
        <label></label>
        <button id="qaRndMel">ğŸ² Randomize Melody</button>
        <button id="qaClrMel">ğŸ§¹ Clear Melody</button>
      </div>
      <div class="row">
        <label></label>
        <button id="qaRndBass">ğŸ² Randomize Bass</button>
                <button id="qaNextBass">ğŸ›ï¸ Switch Bass</button>
        <button id="qaClrBass">ğŸ§¹ Clear Bass</button>
      </div>
      <div class="row">
        <label></label>
        <button id="qaRndMelB">ğŸ² Randomize Lead B</button>
        <button id="qaClrMelB">ğŸ§¹ Clear Lead B</button>
      </div>
      <div class="row">
        <label></label>
        <button id="qaRndDrums2b">ğŸ² Randomize Drums 2</button>
        <button id="qaClrDrums2b">ğŸ§¹ Clear Drums 2</button>
      </div>
    

      <div class="row">
        <label>Layers</label>
        <label class="mutetext"><input id="togLead" type="checkbox" checked/> Lead</label>
        <label class="mutetext"><input id="drumsOn" type="checkbox" checked/> Drums</label>
        <label class="mutetext"><input id="togBass" type="checkbox" checked/> Bass</label>
      </div>
    </fieldset>

    <!-- Key / Scale -->
    <fieldset>
      <legend>Key / Scale</legend>
      <div class="row">
        <label>Root</label><select id="root"></select>
      </div>
      <div class="row">
        <label>Scale</label>
        <select id="scale"><option value="ionian">Ionian (Major)</option>
  <option value="dorian">Dorian</option>
  <option value="phrygian">Phrygian</option>
  <option value="lydian">Lydian</option>
  <option value="mixolydian">Mixolydian</option>
  <option value="aeolian">Aeolian (Natural Minor)</option>
  <option value="locrian">Locrian</option>
  <option value="pent_major">Pentatonic Major</option>
  <option value="pent_minor">Pentatonic Minor</option>
  <!-- legacy labels for older sessions -->
  <option value="major">Major (Ionian)</option>
  <option value="minor">Natural Minor (Aeolian)</option></select>
      </div>
      <div class="row">
        <label>Octave</label>
        <select id="oct"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4" selected>4</option><option value="5">5</option></select>
      </div>
    </fieldset>

    <!-- Tempo & Feel -->
    <fieldset>
      <legend>Tempo & Feel</legend>
      <div class="row">
        <label>BPM</label><input id="bpm" type="range" min="40" max="200" value="110"/><span id="bpmVal" class="pill">110</span>
      </div>
      <div class="row">
        <label>Swing</label><input id="swing" type="range" min="0" max="0.5" step="0.01" value="0.08"/><span id="swingVal" class="pill">0.08</span>
      </div>
      <div class="row">
        <label>Humanize ms Â±</label><input id="humMs" type="range" min="0" max="30" step="1" value="8"/><span id="humMsVal" class="pill">8</span>
      </div>
      <div class="row">
        <label>Humanize vel Â±</label><input id="humVel" type="range" min="0" max="0.6" step="0.02" value="0.18"/><span id="humVelVal" class="pill">0.18</span>
      </div>
    </fieldset>

    <!-- Melody Generator -->
    <fieldset>
      <legend>Melody Generator</legend>
      <div class="row">
        <label>Density</label><input id="melDen" type="range" min="0" max="1" step="0.01" value="0.6"/><span id="melDenVal" class="pill">0.60</span>
      </div>
      <div class="row">
        <label>Range (notes)</label><input id="melRange" type="range" min="4" max="16" step="1" value="8"/><span id="melRangeVal" class="pill">8</span>
      </div>
      <div class="row">
        <button id="melRnd">ğŸ² Randomize Melody</button>
        <button id="melClr">ğŸ§¹ Clear</button>
        <button id="melRepeat" class="good">ğŸ” Toggle Repeat</button><span id="repeatState" class="pill small">On</span>
      </div>
    </fieldset>

    <!-- Lead Synth -->
    <fieldset>
      <legend>Lead Synth</legend>
      <div class="row">
        <label>Enable</label><input id="leadOn" type="checkbox" checked/>
      </div>
      <div class="row">
        <label>Instrument</label>
        <select id="leadInst">
          <option value="sawtooth" selected>Saw</option><option value="sine">Sine</option><option value="square">Square</option><option value="triangle">Triangle</option><option value="supersaw">SuperSaw</option><option value="pluck">Pluck</option><option value="fm">FM</option><option value="noise">Noise</option><option value="piano">Piano</option><option value="bell">Bell</option><option value="organLead">Organ</option><option value="flute">Flute</option><option value="warble">Warble</option><option value="pwm">PWM Lead</option><option value="hollow">Hollow Reed</option><option value="chipPulse">Chiptune Pulse</option>
        </select>
      </div>
      <div class="row">
        <label>Vol</label><input id="leadVol" type="range" min="0" max="1.5" step="0.01" value="0.9"/><span id="leadVolVal" class="pill">0.90</span>
      </div>
      <div class="row">
        <label>Voicing</label>
        <select id="voicing"><option value="uni">Unison</option><option value="oct">Octaves</option><option value="thr">Thirds</option><option value="triad" selected>Triad</option><option value="fif">Fifths</option><option value="six">Sixths</option></select>
      </div>
      <div class="row">
        <label>Delay</label><input id="dlyMix" type="range" min="0" max="0.8" step="0.01" value="0.18"/><span id="dlyMixVal" class="pill">0.18</span>
      </div>
      <div class="row">
        <label>Reverb</label><input id="revMix" type="range" min="0" max="1" step="0.01" value="0.25"/><span id="revMixVal" class="pill">0.25</span>
      </div>
      <div class="row">
        <label>Chorus</label><input id="choMix" type="range" min="0" max="1" step="0.01" value="0.20"/><span id="choMixVal" class="pill">0.20</span>
      </div>
      <div class="row">
        <label>Phaser</label><input id="phMix" type="range" min="0" max="1" step="0.01" value="0.12"/><span id="phMixVal" class="pill">0.12</span>
      </div>
      <div class="row">
        <label>Bitcrush</label><input id="bcMix" type="range" min="0" max="1" step="0.01" value="0"/><span id="bcMixVal" class="pill">0.00</span>
      </div>
      <div class="row">
        <label>Gate</label><input id="leadGate" type="range" min="0.05" max="0.9" step="0.01" value="0.35"/><span id="leadGateVal" class="pill">0.35</span>
      </div>
    </fieldset>
    <!-- Lead Synth B -->
    <fieldset>
      <legend>Lead Synth B</legend>
      <div class="row">
        <label>Enable</label><input id="leadBOn" type="checkbox"/>
      </div>
      <div class="row">
        <label>Instrument</label>
        <select id="leadBInst"><option>(copyingâ€¦)</option></select>
      </div>
      <div class="row">
        <label>Vol</label><input id="leadBVol" type="range" min="0" max="1.2" step="0.01" value="0.75"/><span id="leadBVolVal" class="pill">0.75</span>
      </div>
      <div class="row">
        <label>Octave</label>
        <select id="leadBOct"><option value="-2">-2</option><option value="-1">-1</option><option value="0" selected>0</option><option value="1">+1</option><option value="2">+2</option></select>
      </div>
      <div class="row">
        <label>Mode</label>
        <select id="leadBMode"><option value="pattern" selected>Pattern</option><option value="arpUp">Arp Up</option><option value="arpDown">Arp Down</option><option value="arpRand">Arp Random</option></select>
      </div>
      <div class="row">
        <label></label>
        <button id="melBRnd">ğŸ² Randomize Lead B</button>
        <button id="melBClr">ğŸ§¹ Clear</button>
        <button id="melBRepeat" class="good">ğŸ” Toggle Repeat</button><span id="repeatBState" class="pill small">On</span>
      </div>
    </fieldset>


    <!-- Bassline -->
    <fieldset>
      <legend>Bassline</legend>
      <div class="row">
        <label>Enable</label><input id="bassOn" type="checkbox" checked/>
      </div>
      <div class="row">
        <label>Instrument</label>
        <select id="bassInst"><option value="sub" selected>Sub</option><option value="fm">FM Bass</option><option value="square">Square</option><option value="saw">Saw</option><option value="pluck">Pluck</option></select>
      </div>
      <div class="row">
        <label>Octave</label>
        <select id="bassOct"><option value="1">1</option><option value="2" selected>2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option></select>
      </div>
      <div class="row">
        <label>Density</label><input id="bassDen" type="range" min="0" max="1" step="0.01" value="0.5"/><span id="bassDenVal" class="pill">0.50</span>
      </div>
      <div class="row">
        <label>Vol</label><input id="bassVol" type="range" min="0" max="1.2" step="0.01" value="0.85"/><span id="bassVolVal" class="pill">0.85</span>
        <button id="bassRnd">ğŸ² Randomize Bass</button>
        <button id="bassClr">ğŸ§¹ Clear</button>
      </div>
    </fieldset>
    <!-- Drums 2 (Aux Track) -->
    <fieldset>
      <legend>Drums 2</legend>
      <div class="row">
        <label>Enable</label><input id="drums2On" type="checkbox"/>
      </div>
      <div class="row">
        <label></label>
        <button id="qaRndDrums2">ğŸ² Randomize Drums 2</button>
        <button id="qaClrDrums2">ğŸ§¹ Clear Drums 2</button>
      </div>
      <div class="row">
        <span class="mutetext">Uses current drum kit settings.</span>
      </div>
    </fieldset>


    <!-- Pads -->
    <fieldset>
      <legend>Chords / Pads</legend>
      <div class="row">
        <label>Enable</label><input id="padOn" type="checkbox"/>
      </div>
      <div class="row">
        <label>Instrument</label>
        <select id="padInst"><option value="warm">Warm Pad</option><option value="strings">Strings</option><option value="organ">Organ</option><option value="choir">Formant/Choir</option></select>
      </div>
      <div class="row">
        <label>Voicing</label>
        <select id="padVoicing"><option value="triad" selected>Triad</option><option value="7th">7th</option><option value="sus2">Sus2</option><option value="sus4">Sus4</option></select>
      </div>
      <div class="row">
        <label>Length (beats)</label>
        <select id="padLen"><option value="4">4</option><option value="8">8</option></select>
      </div>
      <div class="row">
        <label>Vol</label><input id="padVol" type="range" min="0" max="1.2" step="0.01" value="0.7"/><span id="padVolVal" class="pill">0.70</span>
      </div>
      <div class="row">
        <label>Prog</label>
        <select id="padProg"><option value="I-V-vi-IV" selected>I-V-vi-IV</option><option value="vi-IV-I-V">vi-IV-I-V</option><option value="ii-V-I-vi">ii-V-I-vi</option><option value="I-vi-ii-V">I-vi-ii-V</option><option value="I-IV-V-IV">I-IV-V-IV</option><option value="random">Random</option></select>
      </div>
    </fieldset>

    <!-- Patterns & Seed -->
    <fieldset>
      <legend>Patterns & Seed</legend>
      <div class="row">
        <label>Seed</label><input id="seed" type="text" placeholder="type a seedâ€¦" style="width:160px"/>
        <button id="applySeed">Apply Seed</button>
        <button id="newSeed">ğŸ’  New Seed</button>
      </div>
      <div class="row">
        <button id="saveBtn">ğŸ’¾ Save (download)</button>
        <input id="loadFile" type="file" accept="application/json" style="display:none"/>
        <button id="loadBtn">ğŸ“‚ Load</button>
        <button id="saveLocal">â­ Save to Browser</button>
        <button id="loadLocal">â†©ï¸ Load from Browser</button>
      </div>
      <div class="row">
        <label>Session Seeds</label>
        <button id="toggleSeedLog">ğŸ“’ Show</button>
        <button id="saveSeedLog">ğŸ’¾ Save Log</button>
        <button id="clearSeedLog">ğŸ§¹ Clear Log</button>
        <span class="mutetext">Auto-captures a seed on Start</span>
      </div>
      <div id="seedLogView" class="list hidden"></div>
    </fieldset>
  </section>

  <!-- Right side: Drum sequencer & keyboard -->
  <section class="panel workspace">
    <h3 style="margin:0">Drum Sequencer</h3>

    <div class="lane">
      <div class="lane-ctrls">
        <span class="tag">Kick</span>
        <select id="kickType"><option value="acoustic">Acoustic</option><option value="808" selected>808</option><option value="clicky">Clicky</option></select>
        <label>Pitch</label>
        <select id="kickPitch"><option value="low">Low</option><option value="med" selected>Med</option><option value="high">High</option></select>
        <label>Tune</label><input id="kickTune" type="range" min="-12" max="12" step="1" value="0"/>
        <label>Vol</label><input id="kickVol" type="range" min="0" max="1.2" step="0.01" value="1"/>
        <label>Delay</label><input id="kickDly" type="range" min="0" max="1" step="0.01" value="0"/>
        <label>Reverb</label><input id="kickRev" type="range" min="0" max="1" step="0.01" value="0.05"/>
      </div>
      <div id="grid-kick" class="grid"></div>
    </div>

    <div class="lane">
      <div class="lane-ctrls">
        <span class="tag">Snare</span>
        <select id="snrType"><option value="noise" selected>Noise</option><option value="808">808</option><option value="clap">Clap</option></select>
        <label>Pitch</label>
        <select id="snrPitch"><option value="low">Low</option><option value="med" selected>Med</option><option value="high">High</option></select>
        <label>Tune</label><input id="snrTune" type="range" min="-12" max="12" step="1" value="0"/>
        <label>Vol</label><input id="snrVol" type="range" min="0" max="1.2" step="0.01" value="0.9"/>
        <label>Delay</label><input id="snrDly" type="range" min="0" max="1" step="0.01" value="0.1"/>
        <label>Reverb</label><input id="snrRev" type="range" min="0" max="1" step="0.01" value="0.25"/>
      </div>
      <div id="grid-snr" class="grid"></div>
    </div>

    <div class="lane">
      <div class="lane-ctrls">
        <span class="tag">Hat</span>
        <select id="hatType"><option value="ch">Closed</option><option value="oh" selected>Open</option><option value="sh">Shaker</option></select>
        <label>Pitch</label>
        <select id="hatPitch"><option value="low">Low</option><option value="med" selected>Med</option><option value="high">High</option></select>
        <label>Tune</label><input id="hatTune" type="range" min="-12" max="12" step="1" value="0"/>
        <label>Vol</label><input id="hatVol" type="range" min="0" max="1.2" step="0.01" value="0.75"/>
        <label>Delay</label><input id="hatDly" type="range" min="0" max="1" step="0.01" value="0.05"/>
        <label>Reverb</label><input id="hatRev" type="range" min="0" max="1" step="0.01" value="0.1"/>
      </div>
      <div id="grid-hat" class="grid"></div>
    </div>

    <div class="lane">
      <div class="lane-ctrls">
        <span class="tag">Perc</span>
        <select id="prcType"><option value="clap">Clap</option><option value="tom" selected>Tom</option><option value="cow">Cowbell</option></select>
        <label>Pitch</label>
        <select id="prcPitch"><option value="low">Low</option><option value="med" selected>Med</option><option value="high">High</option></select>
        <label>Tune</label><input id="prcTune" type="range" min="-12" max="12" step="1" value="0"/>
        <label>Vol</label><input id="prcVol" type="range" min="0" max="1.2" step="0.01" value="0.8"/>
        <label>Delay</label><input id="prcDly" type="range" min="0" max="1" step="0.01" value="0.12"/>
        <label>Reverb</label><input id="prcRev" type="range" min ="0" max="1" step="0.01" value="0.18"/>
      </div>
      <div id="grid-prc" class="grid"></div>
    </div>

    <div class="row">
      <button id="drmRnd">ğŸ² Randomize Drums</button>
      <button id="drmClr">ğŸ§¹ Clear</button>
      <button id="drmSwitch">ğŸ›ï¸ Switch Drums</button>
    </div>

    <h3 style="margin:0">Melody Lane + Keyboard</h3>
    <div class="lane">
      <div class="lane-ctrls">
        <span class="tag">Melody</span>
        <label>Overdub</label><input id="overdub" type="checkbox"/>
        <span class="mutetext">(Play keys to add to loop)</span>
      </div>
      <div id="grid-mel" class="grid"></div>
    </div>

    <div class="kbd-wrap">
      <div id="keyboard" class="keys"></div>
      <div class="kb-row">
        <label>Octave</label>
        <select id="kbOct"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4" selected>4</option><option value="5">5</option></select>
        <span class="mutetext">Tap keys; with <b>Overdub</b> on, notes write to the loop.</span>
      </div>
    </div>
  </section>
</main>

<script>
(function(){
  
// === Envelope Kill Switch behavior & UI lock ===
const envKill = document.getElementById('envEnable'); // checkbox means "Envelope enabled"
const fType = document.getElementById('fType');
const fCut  = document.getElementById('fCut');
const fRes  = document.getElementById('fRes');
const fAmt  = document.getElementById('fAmt');
const fA    = document.getElementById('fA');
const fD    = document.getElementById('fD');
const fS    = document.getElementById('fS');
const fR    = document.getElementById('fR');
const fDrive= document.getElementById('fDrive');

function setEnvUiEnabled(on){
  const nodes = [fType,fCut,fRes,fAmt,fA,fD,fS,fR];
  nodes.forEach(n => { if(n) n.disabled = !on; });
  // Add a subtle visual hint
  if (document.body){
    document.body.classList.toggle('env-disabled', !on);
  }
}

if (envKill){
  setEnvUiEnabled(envKill.checked);
  envKill.addEventListener('change', () => {
    setEnvUiEnabled(envKill.checked);
  });
}

// Scale down envelope-related random deltas so the filter doesn't choke the lead
// (particularly when drive is off). We apply gentle clamping everywhere we jitter.
function gentleEnvClampHz(hz){
  // Keep in musical, non-silencing range
  const minHz = 400;
  const maxHz = 8000;
  return Math.max(minHz, Math.min(maxHz, hz));
}

const noteNames=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const scales = {
  // Canonical modes
  ionian:     [0,2,4,5,7,9,11],
  dorian:     [0,2,3,5,7,9,10],
  phrygian:   [0,1,3,5,7,8,10],
  lydian:     [0,2,4,6,7,9,11],
  mixolydian: [0,2,4,5,7,9,10],
  aeolian:    [0,2,3,5,7,8,10],
  locrian:    [0,1,3,5,6,8,10],

  // Legacy aliases for compatibility
  major: [0,2,4,5,7,9,11],       // Ionian
  minor: [0,2,3,5,7,8,10],       // Aeolian

  // Pentatonics (kept from original)
  pent_major: [0,2,4,7,9],
  pent_minor: [0,3,5,7,10]
};

  // Loudness trims per instrument
  const INST_TRIM = { supersaw:0.38, organLead:0.65, square:0.85, sawtooth:0.90, fm:0.90, pluck:0.85, bell:0.75, piano:0.80, noise:0.55, sine:0.70, triangle:0.90, flute:0.85, warble:0.85, pwm:1.05, hollow:0.85, chipPulse:0.80 };

  function midiToFreq(m){return 440*Math.pow(2,(m-69)/12)}
  function clamp(v,min,max){return Math.min(max,Math.max(min,v))}
  function pick(a,rng=Math.random){return a[Math.floor(rng()*a.length)]}
  function xfnv1a(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,16777619);} return ()=>h>>>0; }
  function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
  let rng=Math.random; function applySeedStr(s){ if(!s||!s.length){ rng=Math.random; return; } const seed=xfnv1a(s)(); rng=mulberry32(seed); }

  const $=id=>document.getElementById(id);
  const bpm=$('bpm'), swing=$('swing'), humMs=$('humMs'), humVel=$('humVel');
  const bpmVal=$('bpmVal'), swingVal=$('swingVal'), humMsVal=$('humMsVal'), humVelVal=$('humVelVal');
  const rootSel=$('root'), scaleSel=$('scale'), octNum=$('oct');
  const leadOn=$('leadOn');
  const leadInst=$('leadInst'), leadVol=$('leadVol'), leadVolVal=$('leadVolVal'), voicingSel=$('voicing');
  const dlyMix=$('dlyMix'), dlyMixVal=$('dlyMixVal'), revMix=$('revMix'), revMixVal=$('revMixVal'), choMix=$('choMix'), choMixVal=$('choMixVal');
  const phMix=$('phMix'), phMixVal=$('phMixVal'), leadGate=$('leadGate'), leadGateVal=$('leadGateVal');
  const bcMix=$('bcMix'), bcMixVal=$('bcMixVal');
  const padOn=$('padOn'), padInst=$('padInst'), padVoicing=$('padVoicing'), padLen=$('padLen'), padVol=$('padVol'), padVolVal=$('padVolVal'), padProg=$('padProg');
  const bassOn=$('bassOn'), bassInst=$('bassInst'), bassOct=$('bassOct'), bassDen=$('bassDen'), bassDenVal=$('bassDenVal'), bassVol=$('bassVol'), bassVolVal=$('bassVolVal'), bassRnd=$('bassRnd'), bassClr=$('bassClr');
  const melDen=$('melDen'), melDenVal=$('melDenVal'), melRange=$('melRange'), melRangeVal=$('melRangeVal');
  const master=$('master'), masterVal=$('masterVal');
  const startBtn=$('startBtn'), stopBtn=$('stopBtn'), rndAll=$('rndAll');
  const beatLED=$('beatLED');
  const recBtn=$('recBtn'), dl=$('dl'), recFmt=$('recFmt');
  const overdub=$('overdub'), kbOct=$('kbOct');
  const autoOn=$('autoOn'), autoMeasures=$('autoMeasures');
  const autoMel=$('autoMel'), autoDrums=$('autoDrums'), autoBass=$('autoBass'), autoChords=$('autoChords'), autoKit=$('autoKit'), autoInst=$('autoInst'), autoKeyScale=$('autoKeyScale');
  const autoTempo=$('autoTempo'), autoTempoDelta=$('autoTempoDelta'), autoTempoDeltaVal=$('autoTempoDeltaVal');
  const autoVoicing=$('autoVoicing');
  const autoFXOn=$('autoFXOn');
  const autoFXDelay=$('autoFXDelay'), autoFXReverb=$('autoFXReverb'), autoFXChorus=$('autoFXChorus'), autoFXPhaser=$('autoFXPhaser'), autoFXBit=$('autoFXBit'), autoGateVar=$('autoGate');
  const autoFxDelta=$('autoFxDelta'), autoFxDeltaVal=$('autoFxDeltaVal');
  const autoGateDelta=$('autoGateDelta'), autoGateDeltaVal=$('autoGateDeltaVal');
  const nextInst=$('nextInst'), autoStatus=$('autoStatus');
  const holdBtn=$('holdBtn'); let hold=false;
  const qaToggle=$('qaToggle'), qaTransport=$('qaTransport');
  const qaRndDrums=$('qaRndDrums'), qaClrDrums=$('qaClrDrums'), qaRndMel=$('qaRndMel'), qaClrMel=$('qaClrMel'), qaRndBass=$('qaRndBass'), qaClrBass=$('qaClrBass');
  const tRndDrums=$('tRndDrums'), tClrDrums=$('tClrDrums'), tRndMel=$('tRndMel'), tClrMel=$('tClrMel'), tRndBass=$('tRndBass'), tClrBass=$('tClrBass');
  const togLead=$('togLead'), drumsOn=$('drumsOn'), togBass=$('togBass');

  const seed=$('seed'), applySeedBtn=$('applySeed'), newSeed=$('newSeed'), saveBtn=$('saveBtn'), loadBtn=$('loadBtn'), loadFile=$('loadFile'), saveLocal=$('saveLocal'), loadLocal=$('loadLocal');
  const seedLogView=$('seedLogView'), toggleSeedLog=$('toggleSeedLog'), saveSeedLog=$('saveSeedLog'), clearSeedLog=$('clearSeedLog');
  const grids={ kick: $('grid-kick'), snr: $('grid-snr'), hat: $('grid-hat'), prc: $('grid-prc'), mel: $('grid-mel') };
  const drumCtrl={ 
    kick:{type:$('kickType'), pitch:$('kickPitch'), tune:$('kickTune'), vol:$('kickVol'), dly:$('kickDly'), rev:$('kickRev')}, 
    snr:{type:$('snrType'), pitch:$('snrPitch'), tune:$('snrTune'), vol:$('snrVol'), dly:$('snrDly'), rev:$('snrRev')}, 
    hat:{type:$('hatType'), pitch:$('hatPitch'), tune:$('hatTune'), vol:$('hatVol'), dly:$('hatDly'), rev:$('hatRev')}, 
    prc:{type:$('prcType'), pitch:$('prcPitch'), tune:$('prcTune'), vol:$('prcVol'), dly:$('prcDly'), rev:$('prcRev')}, 
  };

  noteNames.forEach((n,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=n; rootSel.appendChild(o); }); rootSel.value=0;

  const steps=16; let current16=0, nextNoteTime=0, isPlaying=false, lookahead=null; let measureCount=0; let repeatOn=true;
  const drums={ kick:Array(steps).fill(false), snr:Array(steps).fill(false), hat:Array(steps).fill(false), prc:Array(steps).fill(false) };
  let melody=Array(steps).fill(null); let extra=Array.from({length:steps},()=>[]);
  let bass=Array(steps).fill(null);
  const progressions={ 'I-V-vi-IV':[1,5,6,4], 'vi-IV-I-V':[6,4,1,5], 'ii-V-I-vi':[2,5,1,6], 'I-vi-ii-V':[1,6,2,5], 'I-IV-V-IV':[1,4,5,4] };

  let ctx, masterG, comp, outAnalyser, busDry, delay, dlyGain, rev, revGain, chorus, choGain, phaserMix, mediaDest, mediaRec;
  let phLFO, ap1, ap2, ap3, ap4, apGain; 
  let bcSend, bcNode; 

  // Session Seed log
  const seedLog=[];
  function addSeedToLog(s, reason='start'){ const time=new Date().toLocaleTimeString(); seedLog.unshift({seed:s, time, reason}); renderSeedLog(); }
  function renderSeedLog(){ if(seedLogView.classList.contains('hidden')) return; seedLogView.innerHTML=''; seedLog.forEach((it,idx)=>{ const row=document.createElement('div'); row.className='list-item'; row.innerHTML = `<span class="mutetext">${it.time}</span> <span class="pill small">${it.reason}</span> <code style="font-size:12px">${it.seed}</code>`; const btn=document.createElement('button'); btn.textContent='Use'; btn.onclick=()=>{ seed.value=it.seed; applySeedBtn.click(); }; row.appendChild(btn); seedLogView.appendChild(row); }); }
  toggleSeedLog.onclick=()=> seedLogView.classList.toggle('hidden');
  saveSeedLog.onclick=()=>{ const blob=new Blob([JSON.stringify(seedLog,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='session_seeds.json'; a.click(); };
  clearSeedLog.onclick=()=>{ seedLog.length=0; renderSeedLog(); };

  async function initAudio(){
    if(ctx) return; 
    ctx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
    masterG=ctx.createGain(); masterG.gain.value=parseFloat(master.value);
    comp=new DynamicsCompressorNode(ctx,{threshold:-16,knee:20,ratio:3,attack:0.004,release:0.25});

    delay=new DelayNode(ctx,{delayTime:0.26}); const fb=ctx.createGain(); fb.gain.value=0.28; delay.connect(fb).connect(delay); dlyGain=ctx.createGain(); dlyGain.gain.value=parseFloat(dlyMix.value);
    rev=ctx.createConvolver(); rev.buffer=makeImpulse(ctx,2.2,2.6); revGain=ctx.createGain(); revGain.gain.value=parseFloat(revMix.value);
    chorus=ctx.createDelay(0.06); chorus.delayTime.value=0.016; const lfo=new OscillatorNode(ctx,{type:'sine',frequency:0.7}); const depth=new GainNode(ctx,{gain:0.008}); lfo.connect(depth).connect(chorus.delayTime); lfo.start(); choGain=ctx.createGain(); choGain.gain.value=parseFloat(choMix.value);

    ap1=new BiquadFilterNode(ctx,{type:'allpass',frequency:700,Q:0.7});
    ap2=new BiquadFilterNode(ctx,{type:'allpass',frequency:900,Q:0.7});
    ap3=new BiquadFilterNode(ctx,{type:'allpass',frequency:1200,Q:0.7});
    ap4=new BiquadFilterNode(ctx,{type:'allpass',frequency:1600,Q:0.7});
    phaserMix=ctx.createGain(); phaserMix.gain.value=parseFloat(phMix.value);
    apGain=ctx.createGain(); apGain.gain.value=700; 
    phLFO=new OscillatorNode(ctx,{type:'sine',frequency:0.3}); phLFO.connect(apGain);
    apGain.connect(ap1.frequency); apGain.connect(ap2.frequency); apGain.connect(ap3.frequency); apGain.connect(ap4.frequency);
    phLFO.start();

    outAnalyser=ctx.createAnalyser(); outAnalyser.fftSize=1024;

    busDry=ctx.createGain(); busDry.gain.value=1;
    bcSend=ctx.createGain(); bcSend.gain.value=parseFloat(bcMix.value);
    bcNode=createBitcrusherNode(ctx);
    bcSend.connect(bcNode);

    const sum=ctx.createGain();
    busDry.connect(sum); delay.connect(dlyGain).connect(sum); rev.connect(revGain).connect(sum); chorus.connect(choGain).connect(sum); ap4.connect(phaserMix).connect(sum); bcNode.connect(sum);
    sum.connect(comp).connect(masterG).connect(ctx.destination);
    sum.connect(outAnalyser);

    mediaDest=ctx.createMediaStreamDestination(); masterG.connect(mediaDest);

    startCpuMeter();
  }
  function makeImpulse(ctx, dur, decay){ const len=ctx.sampleRate*dur; const b=ctx.createBuffer(2,len,ctx.sampleRate); for(let ch=0;ch<2;ch++){ const d=b.getChannelData(ch); for(let i=0;i<len;i++){ d[i]=(Math.random()*2-1)*Math.pow(1-i/len,decay); } } return b; }

  function createBitcrusherNode(ctx){
    const proc = ctx.createScriptProcessor(1024,2,2);
    let phasorL=0, phasorR=0; let sampleL=0, sampleR=0;
    proc.bits = 16; 
    proc.reduction = 1; 
    proc.onaudioprocess = e => {
      const il=e.inputBuffer, ol=e.outputBuffer;
      const lIn=il.getChannelData(0), rIn=il.numberOfChannels>1?il.getChannelData(1):lIn;
      const lOut=ol.getChannelData(0), rOut=ol.getChannelData(1);
      const step = Math.pow(0.5, proc.bits);
      for(let i=0;i<lIn.length;i++){
        if(phasorL++ % proc.reduction === 0){ sampleL = Math.round(lIn[i]/step)*step; }
        if(phasorR++ % proc.reduction === 0){ sampleR = Math.round(rIn[i]/step)*step; }
        lOut[i]=sampleL||0; rOut[i]=sampleR||0;
      }
    };
    proc.setFromMix = mix => {
      const mm = clamp(mix,0,1);
      const bits = Math.round(16 - 12*mm);
      const red  = Math.max(1, Math.round(1 + 20*mm));
      proc.bits = bits; proc.reduction = red;
    };
    return proc;
  }

  function voiceOut(){
  const g = new GainNode(ctx,{gain:0});
  // tag the amp node so envGain can find our filter
  g.gain._owner = g;

  // Pre-drive stage (optional)
  const driveOn = !!document.getElementById('fDrive')?.checked;
  const pre = new GainNode(ctx,{gain: driveOn ? 2.0 : 1.0});

  // Per-voice filter (envelope-controlled)
  const filt = new BiquadFilterNode(ctx,{
    type: (document.getElementById('fType')?.value || 'lowpass'),
    frequency: parseFloat(document.getElementById('fCut')?.value || '1800'),
    Q: parseFloat(document.getElementById('fRes')?.value || '1.0')
  });
  g._filt = filt;

  // DC safeguard before FX
  const dc = new BiquadFilterNode(ctx,{type:'highpass', frequency:12});

  // Connect: g -> (drive?) -> filter -> dc
  if (driveOn){
    const ws = new WaveShaperNode(ctx, {oversample:'4x'});
    // soft clip curve
    const n=1024, c=new Float32Array(n);
    for (let i=0;i<n;i++){ const x=i*2/n-1; c[i] = Math.tanh(2.4*x); }
    ws.curve = c;
    g.connect(pre).connect(ws).connect(filt).connect(dc);
  } else {
    g.connect(pre).connect(filt).connect(dc);
  }

  // Mirror original taps
  dc.connect(busDry);
  const d = new GainNode(ctx,{gain:1}); dc.connect(d).connect(delay);
  const r = new GainNode(ctx,{gain:1}); dc.connect(r).connect(rev);
  const c = new GainNode(ctx,{gain:1}); dc.connect(c).connect(chorus);
  const p = new GainNode(ctx,{gain:1}); dc.connect(p).connect(ap1).connect(ap2).connect(ap3).connect(ap4);
  const bcs= new GainNode(ctx,{gain:1}); dc.connect(bcs).connect(bcSend);
  return g;
}
  
function envGain(target,t,dur,a=0.004,d=0.06,s=0.35,vel=1){
  const envOn = !!(document.getElementById('envEnable')?.checked);
  // Always clear any pending ramps for stability
  try{ target.cancelScheduledValues((t||0)-0.01); }catch(e){}
  const owner = target && target._owner;
  const filt  = owner && owner._filt;

  if(!envOn){
    // BYPASS ENVELOPE: simple gate on/off, no ADSR sculpting,
    // and keep the filter neutral (wide open / unity)
    const level = Math.max(0.0001, vel);
    target.setValueAtTime(level, t);
    // rapid tail to avoid clicks on note end
    const relStart = t + Math.max(dur - 0.01, 0);
    target.linearRampToValueAtTime(level, relStart);
    target.setTargetAtTime(0.0001, relStart, 0.010);

    if (filt){
      // Neutralize filter so it can't close down the sound
      try{
        const typ = (document.getElementById('fType')?.value || 'lowpass');
        filt.type = typ;
        // For lowpass, open wide; for others, keep musical defaults
        if (typ === 'lowpass'){
          filt.frequency.setValueAtTime(18000, t);
          filt.Q.setValueAtTime(0.707, t);
        } else {
          // Non-destructive defaults
          filt.frequency.setValueAtTime(gentleEnvClampHz(parseFloat(document.getElementById('fCut')?.value || '1800')), t);
          filt.Q.setValueAtTime(parseFloat(document.getElementById('fRes')?.value || '1.0'), t);
        }
      }catch(e){}
    }
    return;
  }

  // --- Standard ADSR amplitude ---
  const peak = 0.9 * vel;
  target.setValueAtTime(0.0001, Math.max(0, t-0.002));
  target.linearRampToValueAtTime(peak, t + a);
  // Use setTargetAtTime for smoother decay
  target.setTargetAtTime(peak * s, t + a, d);
  const relStart = t + Math.max(dur - 0.02, 0);
  target.setTargetAtTime(0.0001, relStart, 0.015);

  // --- Filter envelope (gentler) ---
  try{
    if (!filt) return;

    const base = gentleEnvClampHz(parseFloat(document.getElementById('fCut')?.value || '1800'));
    const amtStUi = parseFloat(document.getElementById('fAmt')?.value || '5'); // default UI near +5 st
    // Scale the envelope amount down further so it can't over-close
    const amtSt = Math.max(-6, Math.min(6, amtStUi * 0.7));

    // Slightly longer A/D defaults were causing "choke"; keep them conservative
    const A = Math.max(0.002, parseFloat(document.getElementById('fA')?.value || '0.050'));
    const D = Math.max(0.010, parseFloat(document.getElementById('fD')?.value || '0.090'));
    const S = Math.max(0.05,  Math.min(0.95, parseFloat(document.getElementById('fS')?.value || '0.35')));
    const R = Math.max(0.010, parseFloat(document.getElementById('fR')?.value || '0.120'));
    const Qv= Math.max(0.4,  Math.min(10.0, parseFloat(document.getElementById('fRes')?.value || '1.0')));
    const typ= (document.getElementById('fType')?.value || 'lowpass');

    filt.type = typ;
    filt.Q.cancelScheduledValues(Math.max(0, t-0.002));
    filt.Q.setValueAtTime(Qv, t);

    const ratio = Math.pow(2, amtSt/12);
    const fpeak = gentleEnvClampHz(base * ratio);
    const fsus  = gentleEnvClampHz(base * (1 + (ratio-1) * S));

    const f = filt.frequency;
    f.cancelScheduledValues(Math.max(0, t-0.005));
    f.setValueAtTime(base, Math.max(0, t-0.002));
    f.linearRampToValueAtTime(fpeak, t + A);
    f.setTargetAtTime(fsus, t + A, Math.max(0.005, D));
    f.setTargetAtTime(base, relStart, Math.max(0.01, R));
  }catch(e){}
}

  function humanize(t,baseGain){ const ms=parseFloat(humMs.value), vel=parseFloat(humVel.value); return { t: t + ((Math.random()*2-1)*(ms/1000)), g: clamp(baseGain + (Math.random()*2-1)*vel, 0.0001, 1.5) } }

  function playLeadFreq(freq, time, gate){
    const type=leadInst.value;
    const trim = INST_TRIM[type] ?? 1.0;
    const {t,g}=humanize(time, parseFloat(leadVol.value) * trim);
    const out=voiceOut();
    envGain(out.gain,t,gate,0.003,0.06,0.4,g);

    if(type==='noise'){
      const src=ctx.createBufferSource(); const b=ctx.createBuffer(1,ctx.sampleRate*gate,ctx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; src.buffer=b; const bp=new BiquadFilterNode(ctx,{type:'bandpass',frequency:freq,Q:6}); src.connect(bp).connect(out); src.start(t); src.stop(t+gate+0.1); return;
    }
    if(type==='supersaw'){
      const det=[-12,-7,-3,3,7,12]; const mix=new GainNode(ctx,{gain:1/Math.sqrt(det.length)}); mix.connect(out); det.forEach(c=>{ const o=new OscillatorNode(ctx,{type:'sawtooth',frequency:freq}); o.detune.value=c; o.connect(mix); o.start(t); o.stop(t+gate+0.12); }); return;
    }
    if(type==='pluck'){
      const s=new OscillatorNode(ctx,{type:'sine',frequency:freq});
      const n=ctx.createBufferSource(); const b=ctx.createBuffer(1,ctx.sampleRate*Math.min(0.2,gate),ctx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; n.buffer=b;
      const bp=new BiquadFilterNode(ctx,{type:'bandpass',frequency:freq*2,Q:10}); s.connect(out); n.connect(bp).connect(out);
      s.start(t); n.start(t); s.stop(t+gate+0.1); n.stop(t+Math.min(0.2,gate)); return;
    }
    if(type==='fm'){
      const car=new OscillatorNode(ctx,{type:'sine',frequency:freq}); const mod=new OscillatorNode(ctx,{type:'sine',frequency:freq*2.2}); const mg=new GainNode(ctx,{gain:120}); mod.connect(mg).connect(car.frequency); car.connect(out); car.start(t); mod.start(t); car.stop(t+gate+0.1); mod.stop(t+gate+0.1); return;
    }
    if(type==='piano'){
      const body=new OscillatorNode(ctx,{type:'triangle',frequency:freq}); const harm=new OscillatorNode(ctx,{type:'sawtooth',frequency:freq*2}); harm.detune.value=3; const noise=ctx.createBufferSource(); const nb=ctx.createBuffer(1,ctx.sampleRate*0.02,ctx.sampleRate); const nd=nb.getChannelData(0); for(let i=0;i<nd.length;i++) nd[i]=Math.random()*2-1; noise.buffer=nb; const hp=new BiquadFilterNode(ctx,{type:'highpass',frequency:1200}); const lp=new BiquadFilterNode(ctx,{type:'lowpass',frequency:2200,Q:0.4}); body.connect(lp).connect(out); harm.connect(lp); noise.connect(hp).connect(out); body.start(t); harm.start(t); noise.start(t); body.stop(t+gate+0.2); harm.stop(t+0.12); noise.stop(t+0.03); return;
    }
    if(type==='bell'){
      const car=new OscillatorNode(ctx,{type:'sine',frequency:freq}); const mod=new OscillatorNode(ctx,{type:'sine',frequency:freq*2.7}); const mg=new GainNode(ctx,{gain:260}); mod.connect(mg).connect(car.frequency); const lp=new BiquadFilterNode(ctx,{type:'lowpass',frequency:5000}); car.connect(lp).connect(out); car.start(t); mod.start(t); car.stop(t+gate+0.8); mod.stop(t+gate+0.8); return;
    }
    if(type==='organLead'){
      const o=new OscillatorNode(ctx,{type:'square',frequency:freq}); const o2=new OscillatorNode(ctx,{type:'square',frequency:freq}); o2.detune.value=6; const mix=new GainNode(ctx,{gain:1/Math.sqrt(2)}); o.connect(mix); o2.connect(mix); mix.connect(out); o.start(t); o2.start(t); o.stop(t+gate+0.2); o2.stop(t+gate+0.2); return;
    }
    if(type==='flute'){
      const car=new OscillatorNode(ctx,{type:'sine',frequency:freq});
      const vib=new OscillatorNode(ctx,{type:'sine',frequency:5.5}); const vibDepth=new GainNode(ctx,{gain:12}); vib.connect(vibDepth).connect(car.detune);
      const breath=ctx.createBufferSource(); const nb=ctx.createBuffer(1,ctx.sampleRate*Math.min(0.25,gate),ctx.sampleRate); const bd=nb.getChannelData(0); for(let i=0;i<bd.length;i++) bd[i]=Math.random()*2-1; breath.buffer=nb; const bp=new BiquadFilterNode(ctx,{type:'bandpass',frequency:2200,Q:1.2}); const bg=new GainNode(ctx,{gain:0.08}); breath.connect(bp).connect(bg).connect(out);
      car.connect(out); car.start(t); vib.start(t); breath.start(t); car.stop(t+gate+0.2); vib.stop(t+gate+0.2); breath.stop(t+Math.min(0.25,gate)); return;
    }
    if(type==='warble'){
      const car=new OscillatorNode(ctx,{type:'triangle',frequency:freq}); const trem=new GainNode(ctx,{gain:1});
      const lfo1=new OscillatorNode(ctx,{type:'sine',frequency:6}); const lfo2=new OscillatorNode(ctx,{type:'sine',frequency:8});
      const vibDepth=new GainNode(ctx,{gain:10}); const tremDepth=new GainNode(ctx,{gain:0.25});
      lfo1.connect(vibDepth).connect(car.detune); lfo2.connect(tremDepth).connect(trem.gain); car.connect(trem).connect(out);
      car.start(t); lfo1.start(t); lfo2.start(t); car.stop(t+gate+0.2); lfo1.stop(t+gate+0.2); lfo2.stop(t+gate+0.2); return;
    }
    if(type==='pwm'){
      const sq=new OscillatorNode(ctx,{type:'square',frequency:freq});
      const bp=new BiquadFilterNode(ctx,{type:'bandpass',frequency:freq*1.5,Q:8});
      const lfo=new OscillatorNode(ctx,{type:'sine',frequency:2}); const depth=new GainNode(ctx,{gain:freq*0.6});
      lfo.connect(depth).connect(bp.frequency);
      sq.connect(bp).connect(out);
      sq.start(t); lfo.start(t); sq.stop(t+gate+0.2); lfo.stop(t+gate+0.2); return;
    }
    if(type==='hollow'){
      const saw=new OscillatorNode(ctx,{type:'sawtooth',frequency:freq});
      const lp=new BiquadFilterNode(ctx,{type:'lowpass',frequency:1600,Q:0.8});
      const noise=ctx.createBufferSource(); const nb=ctx.createBuffer(1,ctx.sampleRate*gate,ctx.sampleRate); const nd=nb.getChannelData(0); for(let i=0;i<nd.length;i++) nd[i]=Math.random()*2-1; noise.buffer=nb; const hp=new BiquadFilterNode(ctx,{type:'highpass',frequency:1500}); const ng=new GainNode(ctx,{gain:0.06});
      saw.connect(lp).connect(out); noise.connect(hp).connect(ng).connect(out);
      saw.start(t); noise.start(t); saw.stop(t+gate+0.2); noise.stop(t+Math.min(0.12,gate)); return;
    }
    if(type==='chipPulse'){
      const sq=new OscillatorNode(ctx,{type:'square',frequency:freq});
      const vib=new OscillatorNode(ctx,{type:'sine',frequency:7}); const depth=new GainNode(ctx,{gain:18});
      vib.connect(depth).connect(sq.detune);
      sq.connect(out); sq.start(t); vib.start(t); sq.stop(t+gate+0.2); vib.stop(t+gate+0.2); return;
    }
    const o=new OscillatorNode(ctx,{type:type,frequency:freq}); o.connect(out); o.start(t); o.stop(t+gate+0.1);
  }
  function voicingOffsets(){ const v=voicingSel.value; if(v==='uni')return [0]; if(v==='oct')return [0,12]; if(v==='thr')return [0,4]; if(v==='fif')return [0,7]; if(v==='six')return [0,9]; if(v==='triad')return [0,4,7]; return [0]; }
  function playVoiced(midi, time, gate){ const offs=voicingOffsets(); offs.forEach(o=> playLeadFreq(midiToFreq(midi+o), time, gate) ); }

  function padVoicingIntervals(){ const v=padVoicing.value; if(v==='triad')return [0,4,7]; if(v==='7th')return [0,4,7,11]; if(v==='sus2')return [0,2,7]; if(v==='sus4')return [0,5,7]; return [0,4,7]; }
  function degreeToSemitone(deg){ const sc=scales[scaleSel.value]; const root=parseInt(rootSel.value); const oct=parseInt(octNum.value); const rel=sc[(deg-1)%sc.length]; const base=12*(oct+1)+root; return base+rel; }
  function padChordForBar(barIndex){ let prog=padProg.value; if(prog==='random'){ const keys=Object.keys(progressions); prog=pick(keys,Math.random); } const seq=progressions[prog]||[1,5,6,4]; const barsPerChord=parseInt(padLen.value)/4; const chordIdx=Math.floor((barIndex)/barsPerChord)%seq.length; const deg=seq[chordIdx]; const root=degreeToSemitone(deg); const ints=padVoicingIntervals(); return ints.map(i=>root+i); }
  function playPadChord(midiList, time, beatLen){ const vol=parseFloat(padVol.value); const dur=beatLen*parseInt(padLen.value); midiList.forEach((m,i)=>{ const out=voiceOut(); const g=vol*(i===0?0.9:0.7); envGain(out.gain,time,dur,0.06,0.5,0.8,g); const inst=padInst.value; if(inst==='organ'){ const o=new OscillatorNode(ctx,{type:'square',frequency:midiToFreq(m)}); o.connect(out); o.start(time); o.stop(time+dur+0.2); } else if(inst==='strings'){ const o1=new OscillatorNode(ctx,{type:'sawtooth',frequency:midiToFreq(m)}); const o2=new OscillatorNode(ctx,{type:'sawtooth',frequency:midiToFreq(m)}); o2.detune.value=6; o1.connect(out); o2.connect(out); o1.start(time); o2.start(time); o1.stop(time+dur+0.2); o2.stop(time+dur+0.2); } else if(inst==='choir') { const src=new OscillatorNode(ctx,{type:'sawtooth',frequency:midiToFreq(m)}); const bp1=new BiquadFilterNode(ctx,{type:'bandpass',frequency:900,Q:6}); const bp2=new BiquadFilterNode(ctx,{type:'bandpass',frequency:1500,Q:6}); const l1=new OscillatorNode(ctx,{type:'sine',frequency:0.23}); const d1=new GainNode(ctx,{gain:400}); const l2=new OscillatorNode(ctx,{type:'sine',frequency:0.19}); const d2=new GainNode(ctx,{gain:600}); l1.connect(d1).connect(bp1.frequency); l2.connect(d2).connect(bp2.frequency); const lp=new BiquadFilterNode(ctx,{type:'lowpass',frequency:3000,Q:0.3}); const gsum=new GainNode(ctx,{gain:1/Math.sqrt(2)}); src.connect(bp1).connect(gsum); src.connect(bp2).connect(gsum); gsum.connect(lp).connect(out); src.start(time); l1.start(time); l2.start(time); src.stop(time+dur+0.2); l1.stop(time+dur+0.2); l2.stop(time+dur+0.2); } else { const o=new OscillatorNode(ctx,{type:'triangle',frequency:midiToFreq(m)}); const lp=new BiquadFilterNode(ctx,{type:'lowpass',frequency:1800,Q:0.5}); o.connect(lp).connect(out); o.start(time); o.stop(time+dur+0.2); } }); }

  function playBass(midi, time, gate){ const vol=parseFloat(bassVol.value); const out=voiceOut(); envGain(out.gain,time,Math.max(0.1,gate),0.002,0.04,0.5,vol);
    const inst=bassInst.value;
    if(inst==='sub'){ const o=new OscillatorNode(ctx,{type:'sine',frequency:midiToFreq(midi)}); o.connect(out); o.start(time); o.stop(time+gate+0.1); return; }
    if(inst==='fm'){ const car=new OscillatorNode(ctx,{type:'sine',frequency:midiToFreq(midi)}); const mod=new OscillatorNode(ctx,{type:'square',frequency:midiToFreq(midi)*1.5}); const mg=new GainNode(ctx,{gain:80}); mod.connect(mg).connect(car.frequency); car.connect(out); car.start(time); mod.start(time); car.stop(time+gate+0.1); mod.stop(time+gate+0.1); return; }
    if(inst==='pluck'){ const o=new OscillatorNode(ctx,{type:'triangle',frequency:midiToFreq(midi)}); const hp=new BiquadFilterNode(ctx,{type:'highpass',frequency:120,Q:0.4}); o.connect(hp).connect(out); o.start(time); o.stop(time+gate+0.1); return; }
    const o=new OscillatorNode(ctx,{type:inst==='square'?'square':'sawtooth',frequency:midiToFreq(midi)}); o.connect(out); o.start(time); o.stop(time+gate+0.1);
  }

  function drumSend(out, lane){ const cfg = drumCtrl[lane]; const d = new GainNode(ctx,{gain: parseFloat(cfg.dly.value) }); const r = new GainNode(ctx,{gain: parseFloat(cfg.rev.value) }); out.connect(busDry); out.connect(d).connect(delay); out.connect(r).connect(rev); out.connect(chorus); out.connect(ap1); }
  function pitchMul(sel){ return sel==='low'?0.85: (sel==='high'?1.2:1.0); }
  function tuneMul(semi){ return Math.pow(2, (parseInt(semi)||0)/12); }
  function drumKick(t){ const type=drumCtrl.kick.type.value; const pm=pitchMul(drumCtrl.kick.pitch.value) * tuneMul(drumCtrl.kick.tune.value); const vol=parseFloat(drumCtrl.kick.vol.value); const baseF = (type==='808'?55:(type==='clicky'?80:65))*pm; const startF = (type==='clicky'?170:type==='808'?120:150)*pm; const endF=(type==='808'?30:40)*pm; const o=new OscillatorNode(ctx,{type:'sine',frequency:baseF}); const gnode=new GainNode(ctx,{gain:1}); o.connect(gnode); drumSend(gnode,'kick'); o.start(t); o.frequency.setValueAtTime(startF,t); o.frequency.exponentialRampToValueAtTime(endF,t+0.18); gnode.gain.setValueAtTime(vol,t); gnode.gain.exponentialRampToValueAtTime(0.001,t+(type==='808'?0.45:0.28)); if(type==='clicky'){ const click=ctx.createBufferSource(); const b=ctx.createBuffer(1,ctx.sampleRate*0.02,ctx.sampleRate); const d=	b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; click.buffer=b; const hp=new BiquadFilterNode(ctx,{type:'highpass',frequency:5000*pm}); const cg=new GainNode(ctx,{gain:vol*0.6}); click.connect(hp).connect(cg); drumSend(cg,'kick'); click.start(t); click.stop(t+0.02);} o.stop(t+0.6); }
  function drumSnare(t){ const type=drumCtrl.snr.type.value; const pm=pitchMul(drumCtrl.snr.pitch.value) * tuneMul(drumCtrl.snr.tune.value); const vol=parseFloat(drumCtrl.snr.vol.value); if(type==='clap'){ for(let i=0;i<3;i++){ const dly=i*0.012; const src=ctx.createBufferSource(); const b=ctx.createBuffer(1,ctx.sampleRate*0.08,ctx.sampleRate); const d=b.getChannelData(0); for(let j=0;j<d.length;j++) d[j]=Math.random()*2-1; src.buffer=b; const hp=new BiquadFilterNode(ctx,{type:'highpass',frequency:1500*pm}); const gg=new GainNode(ctx,{gain:vol*(i===0?0.9:0.6)}); src.connect(hp).connect(gg); drumSend(gg,'snr'); src.start(t+dly); src.stop(t+dly+0.08);} return; }
    const noise=ctx.createBufferSource(); const b=ctx.createBuffer(1,ctx.sampleRate*0.25,ctx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; noise.buffer=b; const bp=new BiquadFilterNode(ctx,{type:'bandpass',frequency:(type==='808'?1200:1800)*pm,Q:0.8}); const gg=new GainNode(ctx,{gain:vol}); noise.connect(bp).connect(gg); drumSend(gg,'snr'); noise.start(t); gg.gain.setValueAtTime(vol,t); gg.gain.exponentialRampToValueAtTime(0.001,t+(type==='808'?0.3:0.22)); noise.stop(t+0.26); }
  function drumHat(t){ const type=drumCtrl.hat.type.value; const pm=pitchMul(drumCtrl.hat.pitch.value) * tuneMul(drumCtrl.hat.tune.value); const vol=parseFloat(drumCtrl.hat.vol.value); const src=ctx.createBufferSource(); const b=ctx.createBuffer(1,ctx.sampleRate*(type==='oh'?0.25:0.06),ctx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; src.buffer=b; let node; if(type==='sh'){ node=new BiquadFilterNode(ctx,{type:'bandpass',frequency:4000*pm,Q:2}); } else { node=new BiquadFilterNode(ctx,{type:'highpass',frequency:6000*pm,Q:0.7}); } const gg=new GainNode(ctx,{gain:vol*(type==='oh'?0.5:0.35)}); src.connect(node).connect(gg); drumSend(gg,'hat'); src.start(t); gg.gain.setValueAtTime(gg.gain.value,t); gg.gain.exponentialRampToValueAtTime(0.001,t+(type==='oh'?0.22:0.07)); src.stop(t+(type==='oh'?0.25:0.08)); }
  function drumPerc(t){ const type=drumCtrl.prc.type.value; const pm=pitchMul(drumCtrl.prc.pitch.value) * tuneMul(drumCtrl.prc.tune.value); const vol=parseFloat(drumCtrl.prc.vol.value); if(type==='tom'){ const o=new OscillatorNode(ctx,{type:'sine',frequency:180*pm}); const gg=new GainNode(ctx,{gain:vol}); o.connect(gg); drumSend(gg,'prc'); o.start(t); o.frequency.exponentialRampToValueAtTime(80*pm,t+0.15); gg.gain.setValueAtTime(vol,t); gg.gain.exponentialRampToValueAtTime(0.001,t+0.25); o.stop(t+0.3); return; } if(type==='cow'){ const o1=new OscillatorNode(ctx,{type:'square',frequency:540*pm}); const o2=new OscillatorNode(ctx,{type:'square',frequency:800*pm}); const mix=new GainNode(ctx,{gain:1}); o1.connect(mix); o2.connect(mix); const eg=new GainNode(ctx,{gain:1}); mix.connect(eg); drumSend(eg,'prc'); eg.gain.setValueAtTime(vol*0.25,t); eg.gain.exponentialRampToValueAtTime(0.001,t+0.18); o1.start(t); o2.start(t); o1.stop(t+0.2); o2.stop(t+0.2); return; } drumSnare(t); }

  function schedule(){ const secPerBeat=60/parseFloat(bpm.value); const sw=parseFloat(swing.value); while(nextNoteTime < ctx.currentTime + 0.2){ const stepInBeat=current16%4; const swingOffset=((current16%2)===1)? sw*secPerBeat*0.25 : 0; const t=nextNoteTime + swingOffset; 
      if(drumsOn && drumsOn.checked){ if(drums.kick[current16]) drumKick(t); if(drums.snr[current16]) drumSnare(t); if(drums.hat[current16]) drumHat(t); if(drums.prc[current16]) drumPerc(t); }
      const gateLead=parseFloat(leadGate.value)*secPerBeat; const base=melody[current16]; if(leadOn.checked && base!==null){ playVoiced(base, t, gateLead); } const extras=extra[current16]; if(leadOn.checked && extras && extras.length){ extras.forEach(m=> playVoiced(m, t, gateLead)); }
      if(bassOn.checked){ const bnote=bass[current16]; if(bnote!==null){ playBass(bnote, t, gateLead*0.9); } }
      if(padOn.checked){ const lenBeats=parseInt(padLen.value); if(current16===0){
// ==== Last-bar improv (melody + bass) feature ====
try {
  const nBars = parseInt(autoMeasures.value, 10);
  const autoEnabled = autoOn.checked && !hold;
  if (autoEnabled && nBars > 0) {
    const atLastBar = ((measureCount + 1) % nBars) === 0;
    if (autoLastBarImprov && autoLastBarImprov.checked && atLastBar && !improvActive) {
      $('melRnd').click();
      $('bassRnd').click();
      improvActive = true;
      if (typeof autoStatus !== 'undefined' && autoStatus) {
        autoStatus.textContent = 'Last-bar improvâ€¦';
      }
    } else if ((measureCount % nBars) === 0) {
      if (typeof autoMel !== 'undefined' && autoMel.checked) $('melRnd').click();
      if (typeof autoBass !== 'undefined' && autoBass.checked) $('bassRnd').click();
      if (typeof autoDrums !== 'undefined' && autoDrums.checked) $('drmRnd').click();
      if (typeof autoKit !== 'undefined' && autoKit.checked && typeof switchKit === 'function') switchKit();
      if (typeof autoInst !== 'undefined' && autoInst.checked) $('nextInst').click();
      if (typeof autoChords !== 'undefined' && autoChords.checked && typeof randomizeChords === 'function') randomizeChords();
      if (typeof autoVoicing !== 'undefined' && autoVoicing.checked && typeof randomizeVoicing === 'function') randomizeVoicing();
      if (typeof autoKeyScale !== 'undefined' && autoKeyScale.checked && typeof randomizeKeyScale === 'function') randomizeKeyScale();
      if (typeof autoTempo !== 'undefined' && autoTempo.checked && typeof jitterTempo === 'function') jitterTempo();
      improvActive = false;
      if (typeof autoStatus !== 'undefined' && autoStatus) {
        autoStatus.textContent = 'Auto-change';
      }
    }
  }
} catch(e) {
  console.warn('Last-bar improv guard:', e);
}
// ==== end feature ====
 const chord=padChordForBar(measureCount); playPadChord(chord, t, secPerBeat); } if(lenBeats===8 && current16===0 && (measureCount%2===1)){ const chord2=padChordForBar(measureCount); playPadChord(chord2, t, secPerBeat); } }
      if(stepInBeat===0){ beatLED.classList.add('on'); setTimeout(()=>beatLED.classList.remove('on'), 60); }
      advance(); } }
  function advance(){ const spb=60/parseFloat(bpm.value); nextNoteTime += 0.25*spb; const wasEndOfBar=(current16===15); current16=(current16+1)%16; if(!repeatOn && current16===0){ melody.fill(null); extra.forEach(a=>a.length=0); }
    if(wasEndOfBar){ measureCount++; if(autoOn && autoOn.checked && !hold){ const interval=parseInt(autoMeasures.value)||4; if(measureCount % interval === 0){ doAutoChange(); } } updateAutoStatus(); } }
  function start(){ if(isPlaying) return; isPlaying=true; current16=0; measureCount=0; updateAutoStatus(); nextNoteTime=ctx.currentTime+0.05; lookahead=setInterval(schedule,25); ensureSeedAtStart(); }
  function stop(){ if(!isPlaying) return; isPlaying=false; clearInterval(lookahead); lookahead=null; }

  function buildScale(){ const root=parseInt(rootSel.value), oct=parseInt(octNum.value); const sc=scales[scaleSel.value]; const base=12*(oct+1)+root; return sc.map(s=>base+s); }
  function randomDrums(){ for(let i=0;i<16;i++){ drums.kick[i]=(i%4===0)||Math.random()<0.12; drums.snr[i]=(i%8===4)|| (Math.random()<0.08 && i%4!==0); drums.hat[i]=Math.random()<0.55; drums.prc[i]=Math.random()<0.22 && i%4!==0; } renderGrids(); }
  function clearDrums(){ Object.values(drums).forEach(r=>r.fill(false)); renderGrids(); }
  function randomMel(){ const dens=parseFloat(melDen.value); const range=parseInt(melRange.value); const scBase=buildScale(); const sc=[]; for(let o=-1;o<=1;o++) sc.push(...scBase.map(n=>n+12*o)); let any=false; for(let i=0;i<16;i++){ const on=Math.random() < dens * ((i%4===0)?1.1:0.9); if(!on){ melody[i]=null; continue; } const idx=clamp(Math.floor(Math.random()*sc.length + (Math.random()-0.5)*range),0,sc.length-1); melody[i]=sc[idx]; any=true; } if(!any) melody[0]=scBase[0]; renderGrids(); }
  function clearMel(){ melody.fill(null); extra.forEach(a=>a.length=0); renderGrids(); }
  function randomBass(){ const dens=parseFloat(bassDen.value); const root=parseInt(rootSel.value); const sc=scales[scaleSel.value]; const oct=parseInt(bassOct.value); const base=12*(oct+1)+root; const scaleMIDIs=sc.map(s=>base+s); for(let i=0;i<16;i++){ const strong=(i%4===0); const on=Math.random()< (strong? dens*1.2 : dens*0.8); if(on){ const choice=[0,3,4,5][Math.floor(Math.random()*4)]; const m=scaleMIDIs[(choice)%scaleMIDIs.length]; bass[i]=m; } else bass[i]=null; } renderGrids(); }
  function clearBass(){ bass.fill(null); renderGrids(); }
  function randomizeDrumTypes(){ const pickSel=(sel)=>{ const opts=[...sel.options]; sel.value=opts[Math.floor(Math.random()*opts.length)].value; }; pickSel(drumCtrl.kick.type); pickSel(drumCtrl.snr.type); pickSel(drumCtrl.hat.type); pickSel(drumCtrl.prc.type); }
  function randomizeChords(){ if(padProg.value==='random'){ return; } const keys=Object.keys(progressions); padProg.value=keys[Math.floor(Math.random()*keys.length)]; }
  function randomizeKeyScale(){ rootSel.value=Math.floor(Math.random()*12); const keys=Object.keys(scales); scaleSel.value=keys[Math.floor(Math.random()*keys.length)]; }
  function randomizeVoicing(){ const opts=[...voicingSel.options].map(o=>o.value); let next=opts[Math.floor(Math.random()*opts.length)]; if(next===voicingSel.value && opts.length>1){ next=opts[(opts.indexOf(next)+1)%opts.length]; } voicingSel.value=next; }
  function randomizeTempo(){ const delta=parseInt(autoTempoDelta.value)||8; const cur=parseInt(bpm.value); const low=clamp(cur-delta,40,200); const high=clamp(cur+delta,40,200); let next=Math.floor(low + Math.random()*(high-low+1)); if(next===cur){ next = clamp(cur + (Math.random()<0.5?-1:1)*Math.ceil(delta/2), 40, 200); } bpm.value=String(next); bpmVal.textContent=bpm.value; }

  function jitter(val, delta, min=0, max=1){ const off = (Math.random()*2-1)*delta; return clamp(parseFloat(val)+off, min, max); }
  function randomizeFX(){
    const d=parseFloat(autoFxDelta.value)||0.1;
    if(autoFXDelay.checked){ dlyMix.value = jitter(dlyMix.value, d, 0, 0.8); dlyMix.oninput(); }
    if(autoFXReverb.checked){ revMix.value = jitter(revMix.value, d, 0, 1); revMix.oninput(); }
    if(autoFXChorus.checked){ choMix.value = jitter(choMix.value, d, 0, 1); choMix.oninput(); }
    if(autoFXPhaser.checked){ phMix.value = jitter(phMix.value, d, 0, 1); phMix.oninput(); }
    if(autoFXBit.checked){ bcMix.value = jitter(bcMix.value, d, 0, 1); bcMix.oninput(); }
    if(autoGateVar.checked){
      const gDelta=parseFloat(autoGateDelta.value)||0.05;
      leadGate.value = jitter(leadGate.value, gDelta, 0.05, 0.9);
      leadGate.oninput();
    }
  }

  function doAutoChange(){ 
    if(autoKeyScale && autoKeyScale.checked) randomizeKeyScale(); 
    if(autoMel && autoMel.checked) randomMel(); 
    if(autoDrums && autoDrums.checked) randomDrums(); 
    if(autoBass && autoBass.checked) randomBass(); 
    if(autoChords && autoChords.checked) randomizeChords(); 
    if(autoKit && autoKit.checked) randomizeDrumTypes(); 
    if(autoInst && autoInst.checked) switchInstrument('random'); 
    if(autoVoicing && autoVoicing.checked) randomizeVoicing(); 
    if(autoTempo && autoTempo.checked) randomizeTempo();
    if(autoFXOn && autoFXOn.checked) randomizeFX();
  }
  function updateAutoStatus(){ if(!autoStatus) return; if(hold){ autoStatus.textContent='Holding'; return; } if(!autoOn || !autoOn.checked){ autoStatus.textContent='Off'; return; } const interval=parseInt(autoMeasures.value)||4; const left = interval - (measureCount % interval || interval); autoStatus.textContent = `Next in ${left} bar${left>1?'s':''}`; }
  function toggleHold(){ hold = !hold; if(hold){ autoOn.checked=false; holdBtn.textContent='â–¶ï¸ Resume Randomizer'; autoStatus.textContent='Holding'; } else { autoOn.checked=true; holdBtn.textContent='â¸ï¸ Hold Pattern'; updateAutoStatus(); } }

  function renderGrids(){ Object.entries(grids).forEach(([k,el])=>{ el.innerHTML=''; for(let i=0;i<16;i++){ const c=document.createElement('div'); c.className='cell'+((k==='mel'?(melody[i]!==null):(drums[k][i]))?' on':''); c.title=`${k.toUpperCase()} Step ${i+1}`; c.addEventListener('click',()=>{ if(k==='mel'){ melody[i] = (melody[i]===null)? buildScale()[0] : null; } else { drums[k][i]=!drums[k][i]; } c.classList.toggle('on'); }); el.appendChild(c); } }); }
  function renderKeyboard(){ const kb=$('keyboard'); kb.innerHTML=''; const startOct=parseInt(kbOct.value); const totalWhite=14; const whiteOrder=[0,2,4,5,7,9,11]; let x=0; for(let w=0; w<totalWhite; w++){ const octave=startOct + Math.floor((w + (w>=7?-7:0))/7); const semi=whiteOrder[w%7]; const midi=12*(octave+1)+semi; const key=document.createElement('div'); key.className='white'; key.style.left=(x*36)+'px'; const label=document.createElement('div'); label.className='keyname'; label.textContent=noteNames[semi]+octave; key.appendChild(label); key.onmousedown=()=>playKey(midi); key.ontouchstart=(e)=>{e.preventDefault(); playKey(midi);} ; kb.appendChild(key); const blacks=[0,1,3,4,5]; if(blacks.includes(w%7)){ const bsemi=semi+1; const bmidi=12*(octave+1)+bsemi; const b=document.createElement('div'); b.className='black'; b.style.left=(x*36)+'px'; b.onmousedown=()=>playKey(bmidi); b.ontouchstart=(e)=>{e.preventDefault(); playKey(bmidi);} ; kb.appendChild(b); } x++; } }
  function playKey(midi){ if(!ctx) return; const t=ctx.currentTime; playVoiced(midi, t, 0.25); if(isPlaying && overdub.checked){ const step=current16; const arr=extra[step]; if(!arr.includes(midi)) arr.push(midi); const cell=grids.mel.children[step]; cell.classList.add('on'); } }

  function startCpuMeter(){ const buflen=outAnalyser.fftSize; const data=new Uint8Array(buflen); function tick(){ if(!outAnalyser) return; outAnalyser.getByteTimeDomainData(data); let sum=0; for(let i=0;i<buflen;i++) sum+=Math.abs(data[i]-128); const act=clamp((sum/buflen)/20,0,1); $('cpubar').style.width=(act*100).toFixed(0)+'%'; requestAnimationFrame(tick);} requestAnimationFrame(tick); }

  // Recording
  let isRec=false, chunks=[]; let wavNode=null, wavZero=null, wavBuffersL=[], wavBuffersR=[], wavRecording=false, recSampleRate=44100;
  function toggleRec(){ if(!ctx) return; const fmt=recFmt.value||'webm'; if(!isRec){ if(fmt==='wav'){ wavBuffersL=[]; wavBuffersR=[]; recSampleRate=ctx.sampleRate; wavNode=ctx.createScriptProcessor(4096,2,2); wavNode.onaudioprocess=(e)=>{ if(!wavRecording) return; wavBuffersL.push(new Float32Array(e.inputBuffer.getChannelData(0))); wavBuffersR.push(new Float32Array(e.inputBuffer.getChannelData(1))); }; masterG.connect(wavNode); wavZero=ctx.createGain(); wavZero.gain.value=0; wavNode.connect(wavZero).connect(ctx.destination); wavRecording=true; isRec=true; recBtn.textContent='âºï¸ Stop'; dl.style.display='none'; } else { const mime = (fmt==='mp3' && MediaRecorder.isTypeSupported('audio/mp3')) ? 'audio/mp3' : (MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm'); if(fmt==='mp3' && mime!=='audio/mp3'){ alert('MP3 not supported by this browser. Falling back to WebM.'); }
        chunks=[]; mediaRec=new MediaRecorder(mediaDest.stream,{mimeType:mime}); mediaRec.ondataavailable=e=>{ if(e.data.size>0) chunks.push(e.data); }; mediaRec.onstop=()=>{ const ext = (mime==='audio/mp3')?'mp3':'webm'; const blob=new Blob(chunks,{type:mime}); const url=URL.createObjectURL(blob); dl.href=url; dl.textContent='Download last take ('+ext.toUpperCase()+')'; dl.style.display='inline-block'; dl.download='random-studio.'+ext; }; mediaRec.start(); isRec=true; recBtn.textContent='âºï¸ Stop'; dl.style.display='none'; } } else { if(recFmt.value==='wav' && wavRecording){ wavRecording=false; isRec=false; recBtn.textContent='âºï¸ Record'; try{ masterG.disconnect(wavNode); wavNode.disconnect(); wavZero.disconnect(); }catch{} const wavBlob = encodeWAVFromBuffers(wavBuffersL, wavBuffersR, recSampleRate); const url=URL.createObjectURL(wavBlob); dl.href=url; dl.textContent='Download last take (WAV)'; dl.style.display='inline-block'; dl.download='random-studio.wav'; } else { isRec=false; recBtn.textContent='âºï¸ Record'; mediaRec && mediaRec.stop(); } } }
  function mergeFloat32(buffers){ let length=0; for(const b of buffers){ length+=b.length; } const out=new Float32Array(length); let o=0; for(const b of buffers){ out.set(b,o); o+=b.length; } return out; }
  function floatTo16PCM(float32){ const out=new DataView(new ArrayBuffer(float32.length*2)); let offset=0; for(let i=0;i<float32.length;i++){ let s=Math.max(-1,Math.min(1,float32[i])); out.setInt16(offset, s<0 ? s*0x8000 : s*0x7FFF, true); offset+=2; } return out; }
  function interleave(l,r){ const out=new Float32Array(l.length+r.length); for(let i=0,j=0;i<l.length||j<r.length;i++,j++){ out[i+j]=l[i]||0; out[i+j+1]=r[j]||0; } return out; }
  function encodeWAVFromBuffers(bufsL, bufsR, sampleRate){ const left=mergeFloat32(bufsL||[]), right=mergeFloat32(bufsR||[]); const inter = interleave(left,right); const pcm = floatTo16PCM(inter); const wavHeader = new DataView(new ArrayBuffer(44)); const numChannels=2; const bytesPerSample=2; const blockAlign=numChannels*bytesPerSample; const byteRate=sampleRate*blockAlign; const dataSize=pcm.byteLength; writeString(wavHeader,0,'RIFF'); wavHeader.setUint32(4, 36 + dataSize, true); writeString(wavHeader,8,'WAVE'); writeString(wavHeader,12,'fmt '); wavHeader.setUint32(16,16,true); wavHeader.setUint16(20,1,true); wavHeader.setUint16(22,numChannels,true); wavHeader.setUint32(24,sampleRate,true); wavHeader.setUint32(28,byteRate,true); wavHeader.setUint16(32,blockAlign,true); wavHeader.setUint16(34,bytesPerSample*8,true); writeString(wavHeader,36,'data'); wavHeader.setUint32(40,dataSize,true); const wavBuffer = new Uint8Array(44 + dataSize); wavBuffer.set(new Uint8Array(wavHeader.buffer),0); wavBuffer.set(new Uint8Array(pcm.buffer),44); return new Blob([wavBuffer],{type:'audio/wav'}); }
  function writeString(dv,offset,str){ for(let i=0;i<str.length;i++){ dv.setUint8(offset+i, str.charCodeAt(i)); } }

  // UI bindings
  bpm.oninput=()=>{bpmVal.textContent=bpm.value}; swing.oninput=()=>{swingVal.textContent=swing.value}; humMs.oninput=()=>{humMsVal.textContent=humMs.value}; humVel.oninput=()=>{humVelVal.textContent=parseFloat(humVel.value).toFixed(2)};
  master.oninput=()=>{ if(masterG) masterG.gain.value=parseFloat(master.value); masterVal.textContent=parseFloat(master.value).toFixed(2)};
  dlyMix.oninput=()=>{ if(dlyGain) dlyGain.gain.value=parseFloat(dlyMix.value); dlyMixVal.textContent=parseFloat(dlyMix.value).toFixed(2)};
  revMix.oninput=()=>{ if(revGain) revGain.gain.value=parseFloat(revMix.value); revMixVal.textContent=parseFloat(revMix.value).toFixed(2)};
  choMix.oninput=()=>{ if(choGain) choGain.gain.value=parseFloat(choMix.value); choMixVal.textContent=parseFloat(choMix.value).toFixed(2)};
  phMix.oninput=()=>{ if(phaserMix) phaserMix.gain.value=parseFloat(phMix.value); phMixVal.textContent=parseFloat(phMix.value).toFixed(2)};
  leadGate.oninput=()=>{ leadGateVal.textContent=parseFloat(leadGate.value).toFixed(2)};
  leadVol.oninput=()=>{ leadVolVal.textContent=parseFloat(leadVol.value).toFixed(2) };
  bcMix.oninput=()=>{ 
    const mix = parseFloat(bcMix.value);
    bcMixVal.textContent=mix.toFixed(2); 
    if(bcSend) bcSend.gain.value=mix; 
    if(bcNode && bcNode.setFromMix) bcNode.setFromMix(mix);
  };
  autoFxDelta.oninput=()=>{ autoFxDeltaVal.textContent='Â±'+parseFloat(autoFxDelta.value).toFixed(2) };
  autoGateDelta.oninput=()=>{ autoGateDeltaVal.textContent='Â±'+parseFloat(autoGateDelta.value).toFixed(2) };

  melDen.oninput=()=>{ melDenVal.textContent=parseFloat(melDen.value).toFixed(2)}; melRange.oninput=()=>{ melRangeVal.textContent=melRange.value};
  padVol.oninput=()=>{ padVolVal.textContent=parseFloat(padVol.value).toFixed(2)};
  bassVol.oninput=()=>{ bassVolVal.textContent=parseFloat(bassVol.value).toFixed(2)}; bassDen.oninput=()=>{ bassDenVal.textContent=parseFloat(bassDen.value).toFixed(2)};
  autoTempoDelta.oninput=()=>{ autoTempoDeltaVal.textContent='Â±'+autoTempoDelta.value };

  $('drmRnd').onclick=()=>randomDrums(); $('drmClr').onclick=()=>clearDrums();
  $('melRnd').onclick=()=>randomMel(); $('melClr').onclick=()=>clearMel();
  $('melRepeat').onclick=()=>{ repeatOn=!repeatOn; $('repeatState').textContent= repeatOn? 'On':'One-shot'; };
  bassRnd.onclick=()=>randomBass(); bassClr.onclick=()=>clearBass();

  qaRndDrums.onclick=()=>randomDrums(); qaClrDrums.onclick=()=>clearDrums();
  qaRndMel.onclick=()=>randomMel(); qaClrMel.onclick=()=>clearMel();
  qaRndBass.onclick=()=>randomBass(); qaClrBass.onclick=()=>clearBass();
  tRndDrums.onclick=()=>randomDrums(); tClrDrums.onclick=()=>clearDrums();
  tRndMel.onclick=()=>randomMel(); tClrMel.onclick=()=>clearMel();
  tRndBass.onclick=()=>randomBass(); tClrBass.onclick=()=>clearBass();

  togLead.oninput=()=>{ leadOn.checked = togLead.checked; };
  leadOn.oninput=()=>{ togLead.checked = leadOn.checked; };
  togBass.oninput=()=>{ bassOn.checked = togBass.checked; };
  bassOn.oninput=()=>{ togBass.checked = bassOn.checked; };

  qaToggle.onclick=()=>{ qaTransport.classList.toggle('hidden'); };

  $('kbOct').oninput=()=>renderKeyboard();

  if(nextInst) nextInst.onclick=()=>switchInstrument('cycle');
  ;[autoOn, autoMeasures].forEach(el=>{ if(el){ el.oninput=updateAutoStatus; el.onchange=updateAutoStatus; }});
  if(holdBtn) holdBtn.onclick=()=>toggleHold();

  $('startBtn').onclick=async()=>{ await initAudio(); if(ctx.state==='suspended') await ctx.resume(); start(); }
  $('stopBtn').onclick=()=>stop();
  recBtn.onclick=()=>toggleRec();
  rndAll.onclick=()=>{ rootSel.value=Math.floor(Math.random()*12); scaleSel.value=Object.keys(scales)[Math.floor(Math.random()*Object.keys(scales).length)]; leadInst.value=['sawtooth','sine','square','triangle','supersaw','pluck','fm','noise','piano','bell','organLead','flute','warble','pwm','hollow','chipPulse'][Math.floor(Math.random()*15)]; octNum.value = String(3 + Math.floor(Math.random()*3)); bpm.value=90+Math.floor(Math.random()*80); bpmVal.textContent=bpm.value; randomDrums(); randomMel(); randomBass(); if(autoFXOn.checked) randomizeFX(); };

  applySeedBtn.onclick=()=>{ applySeedStr(seed.value.trim()); addSeedToLog(seed.value.trim()||'(unseeded)','apply'); };
  newSeed.onclick=()=>{ const s = genNewSeed(); seed.value=s; applySeedBtn.click(); };

  saveBtn.onclick=()=>{ const state=collectState(); const blob=new Blob([JSON.stringify(state,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='random_music_studio_v7_7.json'; a.click(); };
  loadBtn.onclick=()=>loadFile.click();
  loadFile.onchange=async(e)=>{ const f=e.target.files[0]; if(!f) return; const txt=await f.text(); const obj=JSON.parse(txt); restoreState(obj); };
  saveLocal.onclick=()=>{ localStorage.setItem('random_studio_v7_7', JSON.stringify(collectState())); };
  loadLocal.onclick=()=>{ const txt=localStorage.getItem('random_studio_v7_7'); if(txt){ restoreState(JSON.parse(txt)); } };

  function genNewSeed(){ return 'seed-' + Math.random().toString(36).slice(2,10) + '-' + Date.now().toString(36); }
  function ensureSeedAtStart(){ let s = seed.value.trim(); if(!s){ s = genNewSeed(); seed.value = s; applySeedStr(s); } addSeedToLog(s,'start'); }

  function collectState(){ return {
    bpm:bpm.value,swing:swing.value,humMs:humMs.value,humVel:humVel.value,master:master.value,
    key:{root:rootSel.value,scale:scaleSel.value,oct:octNum.value},
    lead:{on:leadOn.checked,inst:leadInst.value,vol:leadVol.value,voicing:voicingSel.value,gate:leadGate.value,fx:{dly:dlyMix.value,rev:revMix.value,cho:choMix.value,ph:phMix.value,bc:bcMix.value}},
    drums:{on:drumsOn.checked,types:{kick:drumCtrl.kick.type.value,snr:drumCtrl.snr.type.value,hat:drumCtrl.hat.type.value,prc:drumCtrl.prc.type.value}, pitch:{kick:drumCtrl.kick.pitch.value,snr:drumCtrl.snr.pitch.value,hat:drumCtrl.hat.pitch.value,prc:drumCtrl.prc.pitch.value}, tune:{kick:drumCtrl.kick.tune.value,snr:drumCtrl.snr.tune.value,hat:drumCtrl.hat.tune.value,prc:drumCtrl.prc.tune.value}, grids:drums},
    melody:{base:melody,extra:extra,den:melDen.value,range:melRange.value,repeat:repeatOn},
    pads:{on:padOn.checked,inst:padInst.value,voice:padVoicing.value,len:padLen.value,vol:padVol.value,prog:padProg.value},
    bass:{on:bassOn.checked,inst:bassInst.value,oct:bassOct.value,den:bassDen.value,vol:bassVol.value,seq:bass},
    auto:{on:autoOn.checked,measures:autoMeasures.value,mel:autoMel.checked,dr:autoDrums.checked,bass:autoBass.checked,ch:autoChords.checked,kit:autoKit.checked,inst:autoInst.checked,key:autoKeyScale.checked,tempo:autoTempo.checked,tempoDelta:autoTempoDelta.value,voicing:autoVoicing.checked, fx:{on:autoFXOn.checked, d: autoFXDelay.checked, r:autoFXReverb.checked, c:autoFXChorus.checked, p:autoFXPhaser.checked, b:autoFXBit.checked, gate:autoGateVar.checked, dlt:autoFxDelta.value, gDlt:autoGateDelta.value }, hold:hold},
    seed:seed.value,
    seedLog:seedLog
  }}
  function restoreState(s){ if(!s) return; bpm.value=s.bpm||bpm.value; swing.value=s.swing||swing.value; humMs.value=s.humMs||humMs.value; humVel.value=s.humVel||humVel.value; master.value=s.master||master.value; master.oninput();
    if(s.key){ rootSel.value=s.key.root; scaleSel.value=s.key.scale; octNum.value=String(s.key.oct); }
    if(s.lead){ leadOn.checked = s.lead.on!==undefined ? s.lead.on : true; leadInst.value=s.lead.inst; leadVol.value=s.lead.vol; leadVol.oninput(); voicingSel.value=s.lead.voicing; if(s.lead.gate){ leadGate.value=s.lead.gate; leadGate.oninput(); } if(s.lead.fx){ dlyMix.value=s.lead.fx.dly; revMix.value=s.lead.fx.rev; choMix.value=s.lead.fx.cho; phMix.value=s.lead.fx.ph; bcMix.value=s.lead.fx.bc||0; bcMix.oninput(); dlyMix.oninput(); revMix.oninput(); choMix.oninput(); phMix.oninput(); } }
    if(s.drums){ if(s.drums.on!==undefined){ drumsOn.checked = !!s.drums.on; } drumCtrl.kick.type.value=s.drums.types.kick; drumCtrl.snr.type.value=s.drums.types.snr; drumCtrl.hat.type.value=s.drums.types.hat; drumCtrl.prc.type.value=s.drums.types.prc; if(s.drums.pitch){ drumCtrl.kick.pitch.value=s.drums.pitch.kick; drumCtrl.snr.pitch.value=s.drums.pitch.snr; drumCtrl.hat.pitch.value=s.drums.pitch.hat; drumCtrl.prc.pitch.value=s.drums.pitch.prc; } if(s.drums.tune){ drumCtrl.kick.tune.value=s.drums.tune.kick||0; drumCtrl.snr.tune.value=s.drums.tune.snr||0; drumCtrl.hat.tune.value=s.drums.tune.hat||0; drumCtrl.prc.tune.value=s.drums.tune.prc||0; } ['kick','snr','hat','prc'].forEach(k=>{ if(s.drums.grids[k]) drums[k]=s.drums.grids[k].slice(); }); }
    if(s.melody){ melody=s.melody.base.slice(); extra=s.melody.extra.map(a=>a.slice()); melDen.value=s.melody.den; melRange.value=s.melody.range; repeatOn=!!s.melody.repeat; $('repeatState').textContent= repeatOn? 'On':'One-shot'; melDen.oninput(); melRange.oninput(); }
    if(s.pads){ padOn.checked=s.pads.on; padInst.value=s.pads.inst; padVoicing.value=s.pads.voice; padLen.value=s.pads.len; padVol.value=s.pads.vol; padVol.oninput(); padProg.value=s.pads.prog||padProg.value; }
    if(s.bass){ bassOn.checked=s.bass.on; bassInst.value=s.bass.inst; bassOct.value=String(s.bass.oct); bassDen.value=s.bass.den; bassDen.oninput(); bassVol.value=s.bass.vol; bassVol.oninput(); if(s.bass.seq) bass=s.bass.seq.slice(); }
    if(s.auto){ autoOn.checked=s.auto.on; autoMeasures.value=s.auto.measures; autoMel.checked=s.auto.mel; autoDrums.checked=s.auto.dr; autoBass.checked=s.auto.bass; autoChords.checked=s.auto.ch; autoKit.checked=s.auto.kit; autoInst.checked=s.auto.inst; autoKeyScale.checked=!!s.auto.key; autoTempo.checked=!!s.auto.tempo; if(s.auto.tempoDelta){ autoTempoDelta.value=s.auto.tempoDelta; autoTempoDelta.oninput(); } autoVoicing.checked=!!s.auto.voicing; if(s.auto.fx){ autoFXOn.checked=!!s.auto.fx.on; autoFXDelay.checked=!!s.auto.fx.d; autoFXReverb.checked=!!s.auto.fx.r; autoFXChorus.checked=!!s.auto.fx.c; autoFXPhaser.checked=!!s.auto.fx.p; autoFXBit.checked=!!s.auto.fx.b; autoGateVar.checked=!!s.auto.fx.gate; autoFxDelta.value=s.auto.fx.dlt||autoFxDelta.value; autoFxDelta.oninput(); autoGateDelta.value=s.auto.fx.gDlt||autoGateDelta.value; autoGateDelta.oninput(); } hold = !!s.auto.hold; holdBtn.textContent = hold ? 'â–¶ï¸ Resume Randomizer' : 'â¸ï¸ Hold Pattern'; updateAutoStatus(); }
    if(s.seed!==undefined){ seed.value=s.seed; applySeedStr(s.seed.trim()); addSeedToLog(s.seed.trim(),'load'); }
    if(Array.isArray(s.seedLog)){ s.seedLog.forEach(it=> seedLog.push(it)); renderSeedLog(); }
    togLead.checked = leadOn.checked; togBass.checked = bassOn.checked;
    renderGrids(); }
  const leadChoices=['sawtooth','sine','square','triangle','supersaw','pluck','fm','noise','piano','bell','organLead','flute','warble','pwm','hollow','chipPulse'];
  function cycleInstrument(dir=1){ const idx=leadChoices.indexOf(leadInst.value); const next=(idx+dir+leadChoices.length)%leadChoices.length; leadInst.value=leadChoices[next]; }
  function switchInstrument(mode='cycle'){ if(mode==='random'){ leadInst.value=leadChoices[Math.floor(Math.random()*leadChoices.length)]; } else { cycleInstrument(); } }
  function renderRootOptions(){ rootSel.innerHTML=''; noteNames.forEach((n,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=n; rootSel.appendChild(o); }); }
  renderRootOptions();
  renderGrids(); renderKeyboard(); randomDrums(); randomMel(); randomBass();
  ['touchstart','pointerdown','keydown','mousedown'].forEach(ev=>window.addEventListener(ev, async()=>{ if(ctx && ctx.state==='suspended') await ctx.resume(); }, {passive:true}));

// === Switch Drum Types (preserve patterns) ===
function randomChoice(a){ return a[Math.floor(Math.random()*a.length)]; }
function switchDrumTypes(){
  const kickTypes = ['acoustic','808','clicky'];
  const snrTypes  = ['noise','808','clap'];
  const hatTypes  = ['ch','oh','sh'];
  const prcTypes  = ['clap','tom','cow'];
  if (drumCtrl.kick?.type) drumCtrl.kick.type.value = randomChoice(kickTypes);
  if (drumCtrl.snr?.type)  drumCtrl.snr.type.value  = randomChoice(snrTypes);
  if (drumCtrl.hat?.type)  drumCtrl.hat.type.value  = randomChoice(hatTypes);
  if (drumCtrl.prc?.type)  drumCtrl.prc.type.value  = randomChoice(prcTypes);

  // Tasteful random tweaks to character without silencing
  [drumCtrl.kick, drumCtrl.snr, drumCtrl.hat, drumCtrl.prc].forEach(row => {
    if (!row) return;
    if (row.tune) row.tune.value = (Math.random()*24|0)-12;
    if (row.vol)  row.vol.value  = Math.min(1.2, Math.max(0.55, (parseFloat(row.vol.value)||0.9) * (0.8 + Math.random()*0.4)));
    if (row.dly)  row.dly.value  = Math.min(1, Math.max(0, (parseFloat(row.dly.value)||0) * (Math.random()<0.5? 0 : 1)));
    if (row.rev)  row.rev.value  = Math.min(1, Math.max(0, (parseFloat(row.rev.value)||0.1)));
  });
}

const qaSwitchDrumsBtn = document.getElementById('qaSwitchDrums');
if (qaSwitchDrumsBtn) qaSwitchDrumsBtn.addEventListener('click', switchDrumTypes);
const drmSwitchBtn = document.getElementById('drmSwitch');
if (drmSwitchBtn) drmSwitchBtn.addEventListener('click', switchDrumTypes);


// === Auto trigger change melody when last-bar improv is engaged ===
const autoLastBarCb = document.getElementById('autoLastBarImprov');
function triggerMelodyChange(){
  // Prefer the dedicated button if present
  const btn = document.getElementById('melRnd') || document.getElementById('qaRndMel') || document.getElementById('tRndMel');
  if (btn) { btn.click(); return; }
  // Fallback: if there is a function melRnd() in scope, call it
  try{ if (typeof melRnd === 'function') melRnd(); }catch(e){}
}

// Small scheduler shim: when measure counter is one bar before change, do a one-bar improv
// This relies on existing variables: autoOn, autoMeasures, measureCount, etc.
(function(){
  const origAdvance = (window.__advanceStep || null);
  // We'll intercept the section where measureCount increments if we can find the global tick.
  // If not available, we attach to the main animation frame via nextNoteTime guard.
  let lastBarScheduled = false;
  function maybeScheduleLastBar(){
    if (!autoLastBarCb?.checked) { lastBarScheduled = false; return; }
    if (!autoOn?.checked) { lastBarScheduled = false; return; }
    const bars = parseInt(autoMeasures?.value || '2');
    // If we're one bar before the change boundary, schedule a one-bar improv (mel+bass)
    if ((measureCount % bars) === (bars - 1)) {
      if (!lastBarScheduled){
        // Randomize melody + bass for the next bar
        triggerMelodyChange();
        const rb = document.getElementById('bassRnd') || document.getElementById('qaRndBass') || document.getElementById('tRndBass');
        if (rb) rb.click();
        lastBarScheduled = true;
      }
    } else {
      lastBarScheduled = false;
    }
  }

  // Try to hook into the main scheduler loop by wrapping requestAnimationFrame scheduling of steps.
  const _raf = window.requestAnimationFrame;
  window.requestAnimationFrame = function(fn){
    return _raf.call(window, function(time){
      try{ maybeScheduleLastBar(); }catch(e){}
      return fn(time);
    });
  };
})();

})();

const autoLastBarImprov = $('autoLastBarImprov');
let improvActive = false;
</script>

<!-- ENVELOPE FILTER CONTROLS + RUNTIME PATCH -->
<script>
(function(){
  // ---------- UI INSERT ----------
  function el(tag, attrs, ...kids){
    const e = document.createElement(tag);
    if (attrs) for (const [k,v] of Object.entries(attrs)){
      if (k === 'text') e.textContent = v;
      else e.setAttribute(k, v);
    }
    kids.flat().forEach(ch => ch && e.appendChild(ch));
    return e;
  }
  function addEnvelopeUI(){
    // Find the "Lead Synth" fieldset
    const sets = Array.from(document.querySelectorAll('fieldset'));
    const leadFs = sets.find(fs => /Lead\s*Synth/i.test(fs.querySelector('legend')?.textContent||''));
    if (!leadFs) return;

    // Row 1: Filter type / cutoff / resonance
    const row1 = el('div', {class:'row'},
      el('label', {text:'Filter'}),
      (()=>{
        const s = el('select', {id:'fType'});
        ['lowpass','bandpass','highpass'].forEach(k=>{
          const o=document.createElement('option'); o.value=k; o.textContent=k; s.appendChild(o);
        });
        return s;
      })(),
      el('label', {text:'Cutoff'}),
      el('input', {id:'fCut', type:'range', min:'60', max:'12000', step:'1', value:'1800'}),
      el('span', {id:'fCutVal', class:'pill', text:'1800 Hz'}),
      el('label', {text:'Res(Q)'}),
      el('input', {id:'fRes', type:'range', min:'0.2', max:'18', step:'0.1', value:'1.0'}),
      el('span', {id:'fResVal', class:'pill', text:'1.0'}),
    );

    // Row 2: Env Amount + ADSR
    const row2 = el('div', {class:'row'},
      el('label', {text:'Env Amt (Â±st)'}),
      el('input', {id:'fAmt', type:'range', min:'-24', max:'24', step:'1', value:'12'}),
      el('span', {id:'fAmtVal', class:'pill', text:'+12 st'}),
      el('label', {text:'A'}),
      el('input', {id:'fA', type:'range', min:'0.001', max:'1.5', step:'0.001', value:'0.010'}),
      el('span', {id:'fAVal', class:'pill', text:'0.010s'}),
      el('label', {text:'D'}),
      el('input', {id:'fD', type:'range', min:'0.005', max:'2.0', step:'0.001', value:'0.120'}),
      el('span', {id:'fDVal', class:'pill', text:'0.120s'}),
      el('label', {text:'S'}),
      el('input', {id:'fS', type:'range', min:'0', max:'1', step:'0.01', value:'0.40'}),
      el('span', {id:'fSVal', class:'pill', text:'0.40'}),
      el('label', {text:'R'}),
      el('input', {id:'fR', type:'range', min:'0.005', max:'2.0', step:'0.001', value:'0.120'}),
      el('span', {id:'fRVal', class:'pill', text:'0.120s'}),
    );

    // Row 3: Drive
    const row3 = el('div', {class:'row'},
      el('label', {text:'Drive'}),
      el('input', {id:'fDrive', type:'checkbox'}),
      el('span', {id:'fDriveInfo', class:'pill small', text:'off'}),
    );

    // Add rows to Lead Synth fieldset
    leadFs.appendChild(row1);
    leadFs.appendChild(row2);
    leadFs.appendChild(row3);

    // Wiring label updates
    const $ = id => document.getElementById(id);
    function updNum(id, fmt){
      const el = $(id), out = $(id+'Val');
      if (!el || !out) return;
      const fn = ()=> out.textContent = fmt ? fmt(el.value) : String(el.value);
      el.addEventListener('input', fn); fn();
    }
    updNum('fCut', v=> Math.round(v)+' Hz');
    updNum('fRes', v=> Number(v).toFixed(1));
    updNum('fAmt', v=> (Number(v)>=0?'+':'')+Number(v)+' st');
    ['fA','fD','fR'].forEach(id => updNum(id, v=> Number(v).toFixed(3)+'s'));
    updNum('fS', v=> Number(v).toFixed(2));
    const fDrive = $('fDrive'), fDriveInfo = $('fDriveInfo');
    if (fDrive && fDriveInfo){
      const fn = ()=> fDriveInfo.textContent = fDrive.checked ? 'on' : 'off';
      fDrive.addEventListener('input', fn); fn();
    }
  }

  // ---------- AUDIO GRAPH PATCH ----------
  function patchAudio(){
    // Original functions
    const _voiceOut = window.voiceOut;
    const _envGain  = window.envGain;
    if (typeof _voiceOut !== 'function' || typeof _envGain !== 'function') return;

    // Override voiceOut: insert (Drive) -> Filter before existing DC/FX taps
    window.voiceOut = function(){
      const g = new GainNode(ctx, {gain:0});
      g.gain._owner = g; // tag so env can find our filter
      // Pre drive
      const pre = new GainNode(ctx, {gain: (document.getElementById('fDrive')?.checked ? 2.0 : 1.0)});
      // Filter
      const filt = new BiquadFilterNode(ctx, {
        type: (document.getElementById('fType')?.value || 'lowpass'),
        frequency: parseFloat(document.getElementById('fCut')?.value || '1800'),
        Q: parseFloat(document.getElementById('fRes')?.value || '1.0'),
      });
      g._filt = filt;

      // DC high-pass and FX taps (mirrors original voiceOut wiring)
      const dc = new BiquadFilterNode(ctx, {type:'highpass', frequency:12});

      // Optional soft clipper (waveshaper) when Drive enabled
      const driveOn = !!document.getElementById('fDrive')?.checked;
      if (driveOn){
        const ws = new WaveShaperNode(ctx, {oversample:'4x'});
        ws.curve = (function makeCurve(amount=2.4){
          const n=1024, c=new Float32Array(n);
          for (let i=0;i<n;i++){ const x=i*2/n-1; c[i] = Math.tanh(amount*x); }
          return c;
        
// === Switch Drum Types (preserve patterns) ===
function randomChoice(a){ return a[Math.floor(Math.random()*a.length)]; }
function switchDrumTypes(){
  const kickTypes = ['acoustic','808','clicky'];
  const snrTypes  = ['noise','808','clap'];
  const hatTypes  = ['ch','oh','sh'];
  const prcTypes  = ['clap','tom','cow'];
  if (drumCtrl.kick?.type) drumCtrl.kick.type.value = randomChoice(kickTypes);
  if (drumCtrl.snr?.type)  drumCtrl.snr.type.value  = randomChoice(snrTypes);
  if (drumCtrl.hat?.type)  drumCtrl.hat.type.value  = randomChoice(hatTypes);
  if (drumCtrl.prc?.type)  drumCtrl.prc.type.value  = randomChoice(prcTypes);

  // Tasteful random tweaks to character without silencing
  [drumCtrl.kick, drumCtrl.snr, drumCtrl.hat, drumCtrl.prc].forEach(row => {
    if (!row) return;
    if (row.tune) row.tune.value = (Math.random()*24|0)-12;
    if (row.vol)  row.vol.value  = Math.min(1.2, Math.max(0.55, (parseFloat(row.vol.value)||0.9) * (0.8 + Math.random()*0.4)));
    if (row.dly)  row.dly.value  = Math.min(1, Math.max(0, (parseFloat(row.dly.value)||0) * (Math.random()<0.5? 0 : 1)));
    if (row.rev)  row.rev.value  = Math.min(1, Math.max(0, (parseFloat(row.rev.value)||0.1)));
  });
}

const qaSwitchDrumsBtn = document.getElementById('qaSwitchDrums');
if (qaSwitchDrumsBtn) qaSwitchDrumsBtn.addEventListener('click', switchDrumTypes);
const drmSwitchBtn = document.getElementById('drmSwitch');
if (drmSwitchBtn) drmSwitchBtn.addEventListener('click', switchDrumTypes);


// === Auto trigger change melody when last-bar improv is engaged ===
const autoLastBarCb = document.getElementById('autoLastBarImprov');
function triggerMelodyChange(){
  // Prefer the dedicated button if present
  const btn = document.getElementById('melRnd') || document.getElementById('qaRndMel') || document.getElementById('tRndMel');
  if (btn) { btn.click(); return; }
  // Fallback: if there is a function melRnd() in scope, call it
  try{ if (typeof melRnd === 'function') melRnd(); }catch(e){}
}

// Small scheduler shim: when measure counter is one bar before change, do a one-bar improv
// This relies on existing variables: autoOn, autoMeasures, measureCount, etc.
(function(){
  const origAdvance = (window.__advanceStep || null);
  // We'll intercept the section where measureCount increments if we can find the global tick.
  // If not available, we attach to the main animation frame via nextNoteTime guard.
  let lastBarScheduled = false;
  function maybeScheduleLastBar(){
    if (!autoLastBarCb?.checked) { lastBarScheduled = false; return; }
    if (!autoOn?.checked) { lastBarScheduled = false; return; }
    const bars = parseInt(autoMeasures?.value || '2');
    // If we're one bar before the change boundary, schedule a one-bar improv (mel+bass)
    if ((measureCount % bars) === (bars - 1)) {
      if (!lastBarScheduled){
        // Randomize melody + bass for the next bar
        triggerMelodyChange();
        const rb = document.getElementById('bassRnd') || document.getElementById('qaRndBass') || document.getElementById('tRndBass');
        if (rb) rb.click();
        lastBarScheduled = true;
      }
    } else {
      lastBarScheduled = false;
    }
  }

  // Try to hook into the main scheduler loop by wrapping requestAnimationFrame scheduling of steps.
  const _raf = window.requestAnimationFrame;
  window.requestAnimationFrame = function(fn){
    return _raf.call(window, function(time){
      try{ maybeScheduleLastBar(); }catch(e){}
      return fn(time);
    });
  };
})();

})();
        g.connect(pre).connect(ws).connect(filt).connect(dc);
      } else {
        g.connect(pre).connect(filt).connect(dc);
      }

      // taps to global FX (busDry, delay, rev, chorus, phaser chain ap1..ap4, bitcrush send)
      dc.connect(busDry);
      const d = new GainNode(ctx,{gain:1}); dc.connect(d).connect(delay);
      const r = new GainNode(ctx,{gain:1}); dc.connect(r).connect(rev);
      const c = new GainNode(ctx,{gain:1}); dc.connect(c).connect(chorus);
      const p = new GainNode(ctx,{gain:1}); dc.connect(p).connect(ap1).connect(ap2).connect(ap3).connect(ap4);
      const bcs = new GainNode(ctx,{gain:1}); dc.connect(bcs).connect(bcSend);

      return g;
    };

    // Wrap envGain so it also schedules the FILTER envelope when present
    window.envGain = function(target, t, dur, a, d, s, vel){
      // keep original amp envelope
      _envGain(target, t, dur, a, d, s, vel);

      // drive filter envelope only for voices created via voiceOut() (we tagged owner)
      try{
        const owner = target && target._owner;
        const filt  = owner && owner._filt;
        if (!filt) return;

        const base = parseFloat(document.getElementById('fCut')?.value || '1800');
        const amtSt = parseFloat(document.getElementById('fAmt')?.value || '12');
        const A = parseFloat(document.getElementById('fA')?.value || '0.010');
        const D = parseFloat(document.getElementById('fD')?.value || '0.120');
        const S = parseFloat(document.getElementById('fS')?.value || '0.40');
        const R = parseFloat(document.getElementById('fR')?.value || '0.120');
        const Qv= parseFloat(document.getElementById('fRes')?.value || '1.0');
        const typ= (document.getElementById('fType')?.value || 'lowpass');
        filt.type = typ;
        filt.Q.cancelScheduledValues(t-0.002);
        filt.Q.setValueAtTime(Qv, t);

        // convert semitone amount to frequency ratio
        const ratio = Math.pow(2, amtSt/12);
        const peak  = base * ratio;
        const sus   = base * (1 + (ratio-1)*S);
        const end   = base;

        const f = filt.frequency;
        f.cancelScheduledValues(t-0.005);
        f.setValueAtTime(base, t-0.002);
        f.linearRampToValueAtTime(peak, t + A);
        // approximate decay using setTargetAtTime
        f.setTargetAtTime(sus, t + A, Math.max(0.005, D));
        const relStart = t + Math.max(dur - 0.02, 0);
        f.setTargetAtTime(end, relStart, Math.max(0.01, R));
      }catch(e){ /* swallow to avoid clicks */ }
    };
  }

  window.addEventListener('load', function(){
    try{ addEnvelopeUI(); }catch(e){ console.warn(e); }
    try{ patchAudio(); }catch(e){ console.warn(e); }
  });

// === Switch Drum Types (preserve patterns) ===
function randomChoice(a){ return a[Math.floor(Math.random()*a.length)]; }
function switchDrumTypes(){
  const kickTypes = ['acoustic','808','clicky'];
  const snrTypes  = ['noise','808','clap'];
  const hatTypes  = ['ch','oh','sh'];
  const prcTypes  = ['clap','tom','cow'];
  if (drumCtrl.kick?.type) drumCtrl.kick.type.value = randomChoice(kickTypes);
  if (drumCtrl.snr?.type)  drumCtrl.snr.type.value  = randomChoice(snrTypes);
  if (drumCtrl.hat?.type)  drumCtrl.hat.type.value  = randomChoice(hatTypes);
  if (drumCtrl.prc?.type)  drumCtrl.prc.type.value  = randomChoice(prcTypes);

  // Tasteful random tweaks to character without silencing
  [drumCtrl.kick, drumCtrl.snr, drumCtrl.hat, drumCtrl.prc].forEach(row => {
    if (!row) return;
    if (row.tune) row.tune.value = (Math.random()*24|0)-12;
    if (row.vol)  row.vol.value  = Math.min(1.2, Math.max(0.55, (parseFloat(row.vol.value)||0.9) * (0.8 + Math.random()*0.4)));
    if (row.dly)  row.dly.value  = Math.min(1, Math.max(0, (parseFloat(row.dly.value)||0) * (Math.random()<0.5? 0 : 1)));
    if (row.rev)  row.rev.value  = Math.min(1, Math.max(0, (parseFloat(row.rev.value)||0.1)));
  });
}

const qaSwitchDrumsBtn = document.getElementById('qaSwitchDrums');
if (qaSwitchDrumsBtn) qaSwitchDrumsBtn.addEventListener('click', switchDrumTypes);
const drmSwitchBtn = document.getElementById('drmSwitch');
if (drmSwitchBtn) drmSwitchBtn.addEventListener('click', switchDrumTypes);


// === Auto trigger change melody when last-bar improv is engaged ===
const autoLastBarCb = document.getElementById('autoLastBarImprov');
function triggerMelodyChange(){
  // Prefer the dedicated button if present
  const btn = document.getElementById('melRnd') || document.getElementById('qaRndMel') || document.getElementById('tRndMel');
  if (btn) { btn.click(); return; }
  // Fallback: if there is a function melRnd() in scope, call it
  try{ if (typeof melRnd === 'function') melRnd(); }catch(e){}
}

// Small scheduler shim: when measure counter is one bar before change, do a one-bar improv
// This relies on existing variables: autoOn, autoMeasures, measureCount, etc.
(function(){
  const origAdvance = (window.__advanceStep || null);
  // We'll intercept the section where measureCount increments if we can find the global tick.
  // If not available, we attach to the main animation frame via nextNoteTime guard.
  let lastBarScheduled = false;
  function maybeScheduleLastBar(){
    if (!autoLastBarCb?.checked) { lastBarScheduled = false; return; }
    if (!autoOn?.checked) { lastBarScheduled = false; return; }
    const bars = parseInt(autoMeasures?.value || '2');
    // If we're one bar before the change boundary, schedule a one-bar improv (mel+bass)
    if ((measureCount % bars) === (bars - 1)) {
      if (!lastBarScheduled){
        // Randomize melody + bass for the next bar
        triggerMelodyChange();
        const rb = document.getElementById('bassRnd') || document.getElementById('qaRndBass') || document.getElementById('tRndBass');
        if (rb) rb.click();
        lastBarScheduled = true;
      }
    } else {
      lastBarScheduled = false;
    }
  }

  // Try to hook into the main scheduler loop by wrapping requestAnimationFrame scheduling of steps.
  const _raf = window.requestAnimationFrame;
  window.requestAnimationFrame = function(fn){
    return _raf.call(window, function(time){
      try{ maybeScheduleLastBar(); }catch(e){}
      return fn(time);
    });
  };
})();

})();


// === Added: Lead B and Drums 2 ===
(function(){
  function $(id){ return document.getElementById(id); }
  // Copy instrument options to Lead B
  window.addEventListener('DOMContentLoaded', () => {
    const a=$('leadInst'), b=$('leadBInst');
    if(a && b){ b.innerHTML = a.innerHTML; }
    const bindRange = (el, pillId)=>{ const pill=$(pillId); if(el && pillId){ el.addEventListener('input', ()=>{ if(pill) pill.textContent = parseFloat(el.value).toFixed(2); }); } };
    bindRange($('leadBVol'),'leadBVolVal');
  });

  // State
  const steps = 16;
  let melB = Array(steps).fill(null);
  let melBStep = 0;
  let melBRepeat = true;

  const d2 = { len:16, step:0, k:new Array(16).fill(0), s:new Array(16).fill(0), h:new Array(16).fill(0), p:new Array(16).fill(0) };

  function midiToHz(m){ return 440 * Math.pow(2, (m-69)/12); }

  function buildScaleSafe(){
    try{ return buildScale(); }catch(e){ 
      // Fallback: chromatic around A4
      const base = 69; const sc=[0,2,4,5,7,9,11].map(s=>base+s);
      return sc;
    }
  }

  function pickArpNote(sc, dir, idx){
    if(!Array.isArray(sc) || sc.length===0) return 69;
    if(dir==='arpRand') return sc[Math.floor(Math.random()*sc.length)];
    const pos = (idx % sc.length + sc.length) % sc.length;
    if(dir==='arpDown') return sc[(sc.length-1)-pos];
    return sc[pos]; // 'arpUp'
  }

  // Playback wrappers
  function playLeadBFreq(freq, time, gate){
    // Minimal-impact approach: temporarily reuse Lead A synth path
    const instA = $('leadInst'), volA=$('leadVol');
    const saveInst = instA ? instA.value : null;
    const saveVol  = volA ? volA.value : null;
    if(instA) instA.value = $('leadBInst')?.value || saveInst;
    if(volA)  volA.value  = $('leadBVol')?.value  || saveVol;
    try{ if(typeof playLeadFreq === 'function') playLeadFreq(freq, time, gate); }catch(e){}
    finally{
      if(instA && saveInst!==null) instA.value = saveInst;
      if(volA && saveVol!==null)   volA.value  = saveVol;
    }
  }

  // Scheduling hook: wrap schedule()
  if(typeof schedule === 'function'){
    const _origSchedule = schedule;
    window.schedule = function(){
      _origSchedule.apply(this, arguments);
      try{
        const secPerBeat = 60/parseFloat($('bpm').value || '120');
        const swing = parseFloat($('swing')?.value || '0');
        const sw = Math.abs(swing);
        const stepInBeat = (window.current16 ?? 0) % 4;
        const swingOffset = (stepInBeat===1 || stepInBeat===3) ? sw*secPerBeat*0.25 : 0;
        const t = (window.nextNoteTime ?? 0) + swingOffset;
        const gateLead = parseFloat($('leadGate')?.value || '0.35') * secPerBeat;
        const i = (window.current16 ?? 0) % steps;

        // Lead B
        if($('leadBOn')?.checked){
          const mode = $('leadBMode')?.value || 'pattern';
          if(mode==='pattern'){
            const sc = buildScaleSafe();
            const deg = melB[i];
            if(deg!=null){
              const oct = parseInt($('leadBOct')?.value || '0');
              const midi = (sc[deg % sc.length] ?? sc[0]) + 12*oct;
              playLeadBFreq(midiToHz(midi), t, gateLead);
            }
          }else{
            const sc = buildScaleSafe();
            const pos = (melBStep++) % sc.length;
            const midi = pickArpNote(sc, mode, pos);
            const oct = parseInt($('leadBOct')?.value || '0');
            playLeadBFreq(midiToHz(midi + 12*oct), t, gateLead*0.9);
          }
        }

        // Drums 2
        if($('drums2On')?.checked){
          if(d2.k[i]) { try{ drumKick(t); }catch(e){} }
          if(d2.s[i]) { try{ drumSnare(t); }catch(e){} }
          if(d2.h[i]) { try{ drumHat(t); }catch(e){} }
          if(d2.p[i]) { try{ drumPerc(t); }catch(e){} }
          d2.step = (i+1)%d2.len;
        }
      }catch(e){ /* no-op */ }
    };
  }

  // Auto-change hook
  if(typeof doAutoChange === 'function'){
    const _dac = doAutoChange;
    window.doAutoChange = function(){
      _dac.apply(this, arguments);
      try{
        if($('autoMelB')?.checked) randomMelB();
        if($('autoDrums2')?.checked) randomDrums2();
      }catch(e){}
    };
  }

  // API
  window.clearMelB = function(){ melB.fill(null); melBStep=0; };
  window.randomMelB = function(){
    const sc = buildScaleSafe();
    const dens = 0.55;
    melB = melB.map((_,i)=> (Math.random() < dens * ((i%4===0)?1.05:0.95)) ? Math.floor(Math.random()*sc.length) : null);
  };
  window.toggleRepeatB = function(){
    melBRepeat = !melBRepeat; const el=$('repeatBState'); if(el) el.textContent = melBRepeat?'On':'Off';
  };

  window.clearDrums2 = function(){ d2.k.fill(0); d2.s.fill(0); d2.h.fill(0); d2.p.fill(0); };
  window.randomDrums2 = function(){
    for(let i=0;i<d2.len;i++){
      d2.k[i] = (i%4===0) ? 1 : (Math.random()<0.08?1:0);
      d2.s[i] = (i%4===2) ? 1 : (Math.random()<0.06?1:0);
      d2.h[i] = (Math.random()<0.45?1:0);
      d2.p[i] = (Math.random()<0.12?1:0);
    }
  };

  // Wire buttons
  window.addEventListener('DOMContentLoaded', ()=>{
    const bind = (id, fn)=>{ const el=$(id); if(el) el.addEventListener('click', fn); };
    bind('melBRnd', window.randomMelB);
    bind('melBClr', window.clearMelB);
    bind('melBRepeat', window.toggleRepeatB);
    bind('qaRndMelB', window.randomMelB);
    bind('qaClrMelB', window.clearMelB);
    bind('qaRndDrums2', window.randomDrums2);
    bind('qaClrDrums2', window.clearDrums2);
    bind('qaRndDrums2b', window.randomDrums2);
    bind('qaClrDrums2b', window.clearDrums2);
  });

// === Switch Drum Types (preserve patterns) ===
function randomChoice(a){ return a[Math.floor(Math.random()*a.length)]; }
function switchDrumTypes(){
  const kickTypes = ['acoustic','808','clicky'];
  const snrTypes  = ['noise','808','clap'];
  const hatTypes  = ['ch','oh','sh'];
  const prcTypes  = ['clap','tom','cow'];
  if (drumCtrl.kick?.type) drumCtrl.kick.type.value = randomChoice(kickTypes);
  if (drumCtrl.snr?.type)  drumCtrl.snr.type.value  = randomChoice(snrTypes);
  if (drumCtrl.hat?.type)  drumCtrl.hat.type.value  = randomChoice(hatTypes);
  if (drumCtrl.prc?.type)  drumCtrl.prc.type.value  = randomChoice(prcTypes);

  // Tasteful random tweaks to character without silencing
  [drumCtrl.kick, drumCtrl.snr, drumCtrl.hat, drumCtrl.prc].forEach(row => {
    if (!row) return;
    if (row.tune) row.tune.value = (Math.random()*24|0)-12;
    if (row.vol)  row.vol.value  = Math.min(1.2, Math.max(0.55, (parseFloat(row.vol.value)||0.9) * (0.8 + Math.random()*0.4)));
    if (row.dly)  row.dly.value  = Math.min(1, Math.max(0, (parseFloat(row.dly.value)||0) * (Math.random()<0.5? 0 : 1)));
    if (row.rev)  row.rev.value  = Math.min(1, Math.max(0, (parseFloat(row.rev.value)||0.1)));
  });
}

const qaSwitchDrumsBtn = document.getElementById('qaSwitchDrums');
if (qaSwitchDrumsBtn) qaSwitchDrumsBtn.addEventListener('click', switchDrumTypes);
const drmSwitchBtn = document.getElementById('drmSwitch');
if (drmSwitchBtn) drmSwitchBtn.addEventListener('click', switchDrumTypes);


// === Auto trigger change melody when last-bar improv is engaged ===
const autoLastBarCb = document.getElementById('autoLastBarImprov');
function triggerMelodyChange(){
  // Prefer the dedicated button if present
  const btn = document.getElementById('melRnd') || document.getElementById('qaRndMel') || document.getElementById('tRndMel');
  if (btn) { btn.click(); return; }
  // Fallback: if there is a function melRnd() in scope, call it
  try{ if (typeof melRnd === 'function') melRnd(); }catch(e){}
}

// Small scheduler shim: when measure counter is one bar before change, do a one-bar improv
// This relies on existing variables: autoOn, autoMeasures, measureCount, etc.
(function(){
  const origAdvance = (window.__advanceStep || null);
  // We'll intercept the section where measureCount increments if we can find the global tick.
  // If not available, we attach to the main animation frame via nextNoteTime guard.
  let lastBarScheduled = false;
  function maybeScheduleLastBar(){
    if (!autoLastBarCb?.checked) { lastBarScheduled = false; return; }
    if (!autoOn?.checked) { lastBarScheduled = false; return; }
    const bars = parseInt(autoMeasures?.value || '2');
    // If we're one bar before the change boundary, schedule a one-bar improv (mel+bass)
    if ((measureCount % bars) === (bars - 1)) {
      if (!lastBarScheduled){
        // Randomize melody + bass for the next bar
        triggerMelodyChange();
        const rb = document.getElementById('bassRnd') || document.getElementById('qaRndBass') || document.getElementById('tRndBass');
        if (rb) rb.click();
        lastBarScheduled = true;
      }
    } else {
      lastBarScheduled = false;
    }
  }

  // Try to hook into the main scheduler loop by wrapping requestAnimationFrame scheduling of steps.
  const _raf = window.requestAnimationFrame;
  window.requestAnimationFrame = function(fn){
    return _raf.call(window, function(time){
      try{ maybeScheduleLastBar(); }catch(e){}
      return fn(time);
    });
  };
})();

})();
// === /Added ===


// === Added: Bass switch + Envelope nudge ===
(function(){
  function $(id){ return document.getElementById(id); }
  function cycleSelect(el, mode='cycle'){
    if(!el) return;
    const opts = Array.from(el.options).map(o=>o.value);
    if(opts.length===0) return;
    if(mode==='random'){
      el.value = opts[Math.floor(Math.random()*opts.length)];
    }else{
      const i = opts.indexOf(el.value);
      el.value = opts[(i+1+opts.length) % opts.length];
    }
    if (typeof el.oninput === 'function') el.oninput();
    if (typeof el.onchange === 'function') el.onchange();
  }
  window.switchBass = function(mode='cycle'){ const el=$('bassInst'); cycleSelect(el, mode); };
  window.nudgeEnvelopeParams = function(){
    if (!$('envEnable')?.checked) return;
    const jitter=(v,d,min,max)=>Math.max(min,Math.min(max, v+(Math.random()*2-1)*d));
    const set=(id,val)=>{ const el=$(id); if(!el) return; el.value=String(val); el.oninput && el.oninput(); el.onchange && el.onchange(); };
    const get=(id,def)=>parseFloat($(id)?.value||def);
    set('fCut', jitter(get('fCut',1800),120,100,8000));
    set('fAmt', jitter(get('fAmt',12),0.8,0,24));
    set('fA',   jitter(get('fA',0.010),0.01,0.001,0.5));
    set('fD',   jitter(get('fD',0.120),0.03,0.01,0.8));
    set('fS',   jitter(get('fS',0.40),0.05,0,0.95));
    set('fR',   jitter(get('fR',0.120),0.03,0.01,0.8));
    set('fRes', jitter(get('fRes',1.0),0.15,0.1,18.0));
  };
  window.addEventListener('DOMContentLoaded', ()=>{
    const bind=(id,fn)=>{ const el=$(id); if(el) el.addEventListener('click', fn); };
    bind('nextBass', ()=>window.switchBass('cycle'));
    bind('qaNextBass', ()=>window.switchBass('cycle'));
    bind('tNextBass', ()=>window.switchBass('cycle'));
  });

// === Switch Drum Types (preserve patterns) ===
function randomChoice(a){ return a[Math.floor(Math.random()*a.length)]; }
function switchDrumTypes(){
  const kickTypes = ['acoustic','808','clicky'];
  const snrTypes  = ['noise','808','clap'];
  const hatTypes  = ['ch','oh','sh'];
  const prcTypes  = ['clap','tom','cow'];
  if (drumCtrl.kick?.type) drumCtrl.kick.type.value = randomChoice(kickTypes);
  if (drumCtrl.snr?.type)  drumCtrl.snr.type.value  = randomChoice(snrTypes);
  if (drumCtrl.hat?.type)  drumCtrl.hat.type.value  = randomChoice(hatTypes);
  if (drumCtrl.prc?.type)  drumCtrl.prc.type.value  = randomChoice(prcTypes);

  // Tasteful random tweaks to character without silencing
  [drumCtrl.kick, drumCtrl.snr, drumCtrl.hat, drumCtrl.prc].forEach(row => {
    if (!row) return;
    if (row.tune) row.tune.value = (Math.random()*24|0)-12;
    if (row.vol)  row.vol.value  = Math.min(1.2, Math.max(0.55, (parseFloat(row.vol.value)||0.9) * (0.8 + Math.random()*0.4)));
    if (row.dly)  row.dly.value  = Math.min(1, Math.max(0, (parseFloat(row.dly.value)||0) * (Math.random()<0.5? 0 : 1)));
    if (row.rev)  row.rev.value  = Math.min(1, Math.max(0, (parseFloat(row.rev.value)||0.1)));
  });
}

const qaSwitchDrumsBtn = document.getElementById('qaSwitchDrums');
if (qaSwitchDrumsBtn) qaSwitchDrumsBtn.addEventListener('click', switchDrumTypes);
const drmSwitchBtn = document.getElementById('drmSwitch');
if (drmSwitchBtn) drmSwitchBtn.addEventListener('click', switchDrumTypes);


// === Auto trigger change melody when last-bar improv is engaged ===
const autoLastBarCb = document.getElementById('autoLastBarImprov');
function triggerMelodyChange(){
  // Prefer the dedicated button if present
  const btn = document.getElementById('melRnd') || document.getElementById('qaRndMel') || document.getElementById('tRndMel');
  if (btn) { btn.click(); return; }
  // Fallback: if there is a function melRnd() in scope, call it
  try{ if (typeof melRnd === 'function') melRnd(); }catch(e){}
}

// Small scheduler shim: when measure counter is one bar before change, do a one-bar improv
// This relies on existing variables: autoOn, autoMeasures, measureCount, etc.
(function(){
  const origAdvance = (window.__advanceStep || null);
  // We'll intercept the section where measureCount increments if we can find the global tick.
  // If not available, we attach to the main animation frame via nextNoteTime guard.
  let lastBarScheduled = false;
  function maybeScheduleLastBar(){
    if (!autoLastBarCb?.checked) { lastBarScheduled = false; return; }
    if (!autoOn?.checked) { lastBarScheduled = false; return; }
    const bars = parseInt(autoMeasures?.value || '2');
    // If we're one bar before the change boundary, schedule a one-bar improv (mel+bass)
    if ((measureCount % bars) === (bars - 1)) {
      if (!lastBarScheduled){
        // Randomize melody + bass for the next bar
        triggerMelodyChange();
        const rb = document.getElementById('bassRnd') || document.getElementById('qaRndBass') || document.getElementById('tRndBass');
        if (rb) rb.click();
        lastBarScheduled = true;
      }
    } else {
      lastBarScheduled = false;
    }
  }

  // Try to hook into the main scheduler loop by wrapping requestAnimationFrame scheduling of steps.
  const _raf = window.requestAnimationFrame;
  window.requestAnimationFrame = function(fn){
    return _raf.call(window, function(time){
      try{ maybeScheduleLastBar(); }catch(e){}
      return fn(time);
    });
  };
})();

})();
// Auto-change hook for envelope nudge
if (typeof doAutoChange === 'function'){
  const _dac2 = doAutoChange;
  window.doAutoChange = function(){
    _dac2.apply(this, arguments);
    if(document.getElementById('autoEnvNudge')?.checked){ try{ nudgeEnvelopeParams(); }catch(e){} }
  };
}
// === /Added ===
</script>
<!-- MERGE PATCH: Audio Unlock + Env Toggle + Env Nudge -->
<script>(function(){const $=(s,r=document)=>r.querySelector(s),$$=(s,r=document)=>Array.from(r.querySelectorAll(s));
function attachAudioResume(g){const r=async()=>{try{const c=g&&g();if(c&&c.state==='suspended')await c.resume()}catch(e){}};['pointerdown','touchstart','keydown','mousedown'].forEach(ev=>window.addEventListener(ev,r,{passive:!0}));const b=$('#startBtn')||$('#start')||$('#play');b&&b.addEventListener('click',r)}
window.__ctxGetter||(window.__ctxGetter=function(){return window.ctx||window.audioCtx||null});attachAudioResume(window.__ctxGetter);
function envOn(){const el=document.getElementById('envEnable')||document.getElementById('fEnvOn');return el?!!el.checked:!0}
if(typeof window.voiceOut==='function'&&!window.__voiceOutPatched){const o=window.voiceOut;window.voiceOut=function(){const g=o.apply(this,arguments);try{const f=g&&(g._filt||g._filter);const te=document.getElementById('fType');const typ=te?te.value:'lowpass';f&&(f.type=envOn()?typ:'allpass')}catch(e){}return g};window.__voiceOutPatched=!0}
if(typeof window.envGain==='function'&&!window.__envGainPatched){window.__origEnvGain=window.envGain}
window.envGain=function(target,t,dur,a=0.004,d=0.06,s=0.35,vel=1){const peak=.9*(vel??1);try{target.cancelScheduledValues(t-.005);target.setValueAtTime(.0001,t-.002);target.linearRampToValueAtTime(peak,t+(a??.004));target.setTargetAtTime(peak*(s??.35),t+(a??.004),(d??.06));const rs=t+Math.max((dur??.15)-.02,0);target.setTargetAtTime(.0001,rs,.015)}catch(e){}try{const owner=target&&target._owner,f=owner&&(owner._filt||owner._filter);if(!f)return;const te=document.getElementById('fType'),ce=document.getElementById('fCut'),qe=document.getElementById('fRes'),ae=document.getElementById('fAmt'),Ae=document.getElementById('fA'),De=document.getElementById('fD'),Se=document.getElementById('fS'),Re=document.getElementById('fR');if(!envOn()){te&&(f.type='allpass');const base=ce?parseFloat(ce.value):1800;f.frequency.cancelScheduledValues(t-.002);f.frequency.setValueAtTime(base,t-.002);return}const typ=te?te.value:'lowpass',base=ce?parseFloat(ce.value):1800,Qv=qe?parseFloat(qe.value):1,amtSt=ae?parseFloat(ae.value):12,fA=Ae?parseFloat(Ae.value):.01,fD=De?parseFloat(De.value):.12,fS=Se?parseFloat(Se.value):.4,fR=Re?parseFloat(Re.value):.12;f.type=typ;f.Q.cancelScheduledValues(t-.002);f.Q.setValueAtTime(Qv,t);const ratio=Math.pow(2,amtSt/12),fpeak=base*ratio,fsus=base*(1+(ratio-1)*fS),rs=t+Math.max((dur??.15)-.02,0),F=f.frequency;F.cancelScheduledValues(t-.005);F.setValueAtTime(base,t-.002);F.linearRampToValueAtTime(fpeak,t+fA);F.setTargetAtTime(fsus,t+fA,Math.max(.005,fD));F.setTargetAtTime(base,rs,Math.max(.01,fR))}catch(e){}}; 
function clamp(v,a,b){return Math.min(b,Math.max(a,v))}function mutate(el,v){el&&(el.value=v,el.dispatchEvent(new Event('input')))}
function nudgeEnv(){if(!$('#autoEnvNudge')||!$('#autoEnvNudge').checked)return;const ao=$('#autoOn')||$('#autoChange')||$('#autoOnChk');if(!ao||!ao.checked)return;const p=$('#autoEnvPct'),pct=p?parseFloat(p.value):.15,m=v=>v*(1+(Math.random()*2-1)*pct),fCut=$('#fCut'),fRes=$('#fRes'),fAmt=$('#fAmt'),fA=$('#fA'),fD=$('#fD'),fS=$('#fS'),fR=$('#fR');fCut&&mutate(fCut,clamp(m(parseFloat(fCut.value)),60,12000));fRes&&mutate(fRes,clamp(m(parseFloat(fRes.value)),.2,18));if(fAmt){let v=Math.round(parseFloat(fAmt.value)+(Math.random()*2-1)*Math.max(1,Math.round(24*pct)));mutate(fAmt,clamp(v,-24,24))}fA&&mutate(fA,clamp(m(parseFloat(fA.value)),.001,1.5));fD&&mutate(fD,clamp(m(parseFloat(fD.value)),.005,2));fS&&mutate(fS,clamp(m(parseFloat(fS.value)),0,1));fR&&mutate(fR,clamp(m(parseFloat(fR.value)),.005,2))} 
(function(){const led=$('#beatLED');if(!led)return;const ms=$('#autoMeasures')||$('#autoBars');let bars=0;new MutationObserver(()=>{bars++;const mod=parseInt(ms?ms.value:'2',10)||2;if(bars%mod===0)nudgeEnv()}).observe(led,{attributes:!0,attributeFilter:['class']})
// === Switch Drum Types (preserve patterns) ===
function randomChoice(a){ return a[Math.floor(Math.random()*a.length)]; }
function switchDrumTypes(){
  const kickTypes = ['acoustic','808','clicky'];
  const snrTypes  = ['noise','808','clap'];
  const hatTypes  = ['ch','oh','sh'];
  const prcTypes  = ['clap','tom','cow'];
  if (drumCtrl.kick?.type) drumCtrl.kick.type.value = randomChoice(kickTypes);
  if (drumCtrl.snr?.type)  drumCtrl.snr.type.value  = randomChoice(snrTypes);
  if (drumCtrl.hat?.type)  drumCtrl.hat.type.value  = randomChoice(hatTypes);
  if (drumCtrl.prc?.type)  drumCtrl.prc.type.value  = randomChoice(prcTypes);

  // Tasteful random tweaks to character without silencing
  [drumCtrl.kick, drumCtrl.snr, drumCtrl.hat, drumCtrl.prc].forEach(row => {
    if (!row) return;
    if (row.tune) row.tune.value = (Math.random()*24|0)-12;
    if (row.vol)  row.vol.value  = Math.min(1.2, Math.max(0.55, (parseFloat(row.vol.value)||0.9) * (0.8 + Math.random()*0.4)));
    if (row.dly)  row.dly.value  = Math.min(1, Math.max(0, (parseFloat(row.dly.value)||0) * (Math.random()<0.5? 0 : 1)));
    if (row.rev)  row.rev.value  = Math.min(1, Math.max(0, (parseFloat(row.rev.value)||0.1)));
  });
}

const qaSwitchDrumsBtn = document.getElementById('qaSwitchDrums');
if (qaSwitchDrumsBtn) qaSwitchDrumsBtn.addEventListener('click', switchDrumTypes);
const drmSwitchBtn = document.getElementById('drmSwitch');
if (drmSwitchBtn) drmSwitchBtn.addEventListener('click', switchDrumTypes);


// === Auto trigger change melody when last-bar improv is engaged ===
const autoLastBarCb = document.getElementById('autoLastBarImprov');
function triggerMelodyChange(){
  // Prefer the dedicated button if present
  const btn = document.getElementById('melRnd') || document.getElementById('qaRndMel') || document.getElementById('tRndMel');
  if (btn) { btn.click(); return; }
  // Fallback: if there is a function melRnd() in scope, call it
  try{ if (typeof melRnd === 'function') melRnd(); }catch(e){}
}

// Small scheduler shim: when measure counter is one bar before change, do a one-bar improv
// This relies on existing variables: autoOn, autoMeasures, measureCount, etc.
(function(){
  const origAdvance = (window.__advanceStep || null);
  // We'll intercept the section where measureCount increments if we can find the global tick.
  // If not available, we attach to the main animation frame via nextNoteTime guard.
  let lastBarScheduled = false;
  function maybeScheduleLastBar(){
    if (!autoLastBarCb?.checked) { lastBarScheduled = false; return; }
    if (!autoOn?.checked) { lastBarScheduled = false; return; }
    const bars = parseInt(autoMeasures?.value || '2');
    // If we're one bar before the change boundary, schedule a one-bar improv (mel+bass)
    if ((measureCount % bars) === (bars - 1)) {
      if (!lastBarScheduled){
        // Randomize melody + bass for the next bar
        triggerMelodyChange();
        const rb = document.getElementById('bassRnd') || document.getElementById('qaRndBass') || document.getElementById('tRndBass');
        if (rb) rb.click();
        lastBarScheduled = true;
      }
    } else {
      lastBarScheduled = false;
    }
  }

  // Try to hook into the main scheduler loop by wrapping requestAnimationFrame scheduling of steps.
  const _raf = window.requestAnimationFrame;
  window.requestAnimationFrame = function(fn){
    return _raf.call(window, function(time){
      try{ maybeScheduleLastBar(); }catch(e){}
      return fn(time);
    });
  };
})();

})(); 
(function(){if($('#nextBass')||$('#switchBassBtn'))return;const a=$('#nextInst')||$$('button').find(b=>/switch instrument/i.test(b.textContent||''));if(!a||!a.parentNode)return;const b=document.createElement('button');b.id='switchBassBtn';b.textContent='ğŸ›ï¸ Switch Bass';b.addEventListener('click',()=>{const s=$('#bassInst');if(!s)return;s.selectedIndex=(s.selectedIndex+1)%s.options.length;s.dispatchEvent(new Event('input'))});a.parentNode.insertBefore(b,a.nextSibling)
// === Switch Drum Types (preserve patterns) ===
function randomChoice(a){ return a[Math.floor(Math.random()*a.length)]; }
function switchDrumTypes(){
  const kickTypes = ['acoustic','808','clicky'];
  const snrTypes  = ['noise','808','clap'];
  const hatTypes  = ['ch','oh','sh'];
  const prcTypes  = ['clap','tom','cow'];
  if (drumCtrl.kick?.type) drumCtrl.kick.type.value = randomChoice(kickTypes);
  if (drumCtrl.snr?.type)  drumCtrl.snr.type.value  = randomChoice(snrTypes);
  if (drumCtrl.hat?.type)  drumCtrl.hat.type.value  = randomChoice(hatTypes);
  if (drumCtrl.prc?.type)  drumCtrl.prc.type.value  = randomChoice(prcTypes);

  // Tasteful random tweaks to character without silencing
  [drumCtrl.kick, drumCtrl.snr, drumCtrl.hat, drumCtrl.prc].forEach(row => {
    if (!row) return;
    if (row.tune) row.tune.value = (Math.random()*24|0)-12;
    if (row.vol)  row.vol.value  = Math.min(1.2, Math.max(0.55, (parseFloat(row.vol.value)||0.9) * (0.8 + Math.random()*0.4)));
    if (row.dly)  row.dly.value  = Math.min(1, Math.max(0, (parseFloat(row.dly.value)||0) * (Math.random()<0.5? 0 : 1)));
    if (row.rev)  row.rev.value  = Math.min(1, Math.max(0, (parseFloat(row.rev.value)||0.1)));
  });
}

const qaSwitchDrumsBtn = document.getElementById('qaSwitchDrums');
if (qaSwitchDrumsBtn) qaSwitchDrumsBtn.addEventListener('click', switchDrumTypes);
const drmSwitchBtn = document.getElementById('drmSwitch');
if (drmSwitchBtn) drmSwitchBtn.addEventListener('click', switchDrumTypes);


// === Auto trigger change melody when last-bar improv is engaged ===
const autoLastBarCb = document.getElementById('autoLastBarImprov');
function triggerMelodyChange(){
  // Prefer the dedicated button if present
  const btn = document.getElementById('melRnd') || document.getElementById('qaRndMel') || document.getElementById('tRndMel');
  if (btn) { btn.click(); return; }
  // Fallback: if there is a function melRnd() in scope, call it
  try{ if (typeof melRnd === 'function') melRnd(); }catch(e){}
}

// Small scheduler shim: when measure counter is one bar before change, do a one-bar improv
// This relies on existing variables: autoOn, autoMeasures, measureCount, etc.
(function(){
  const origAdvance = (window.__advanceStep || null);
  // We'll intercept the section where measureCount increments if we can find the global tick.
  // If not available, we attach to the main animation frame via nextNoteTime guard.
  let lastBarScheduled = false;
  function maybeScheduleLastBar(){
    if (!autoLastBarCb?.checked) { lastBarScheduled = false; return; }
    if (!autoOn?.checked) { lastBarScheduled = false; return; }
    const bars = parseInt(autoMeasures?.value || '2');
    // If we're one bar before the change boundary, schedule a one-bar improv (mel+bass)
    if ((measureCount % bars) === (bars - 1)) {
      if (!lastBarScheduled){
        // Randomize melody + bass for the next bar
        triggerMelodyChange();
        const rb = document.getElementById('bassRnd') || document.getElementById('qaRndBass') || document.getElementById('tRndBass');
        if (rb) rb.click();
        lastBarScheduled = true;
      }
    } else {
      lastBarScheduled = false;
    }
  }

  // Try to hook into the main scheduler loop by wrapping requestAnimationFrame scheduling of steps.
  const _raf = window.requestAnimationFrame;
  window.requestAnimationFrame = function(fn){
    return _raf.call(window, function(time){
      try{ maybeScheduleLastBar(); }catch(e){}
      return fn(time);
    });
  };
})();

})(); 

// === Switch Drum Types (preserve patterns) ===
function randomChoice(a){ return a[Math.floor(Math.random()*a.length)]; }
function switchDrumTypes(){
  const kickTypes = ['acoustic','808','clicky'];
  const snrTypes  = ['noise','808','clap'];
  const hatTypes  = ['ch','oh','sh'];
  const prcTypes  = ['clap','tom','cow'];
  if (drumCtrl.kick?.type) drumCtrl.kick.type.value = randomChoice(kickTypes);
  if (drumCtrl.snr?.type)  drumCtrl.snr.type.value  = randomChoice(snrTypes);
  if (drumCtrl.hat?.type)  drumCtrl.hat.type.value  = randomChoice(hatTypes);
  if (drumCtrl.prc?.type)  drumCtrl.prc.type.value  = randomChoice(prcTypes);

  // Tasteful random tweaks to character without silencing
  [drumCtrl.kick, drumCtrl.snr, drumCtrl.hat, drumCtrl.prc].forEach(row => {
    if (!row) return;
    if (row.tune) row.tune.value = (Math.random()*24|0)-12;
    if (row.vol)  row.vol.value  = Math.min(1.2, Math.max(0.55, (parseFloat(row.vol.value)||0.9) * (0.8 + Math.random()*0.4)));
    if (row.dly)  row.dly.value  = Math.min(1, Math.max(0, (parseFloat(row.dly.value)||0) * (Math.random()<0.5? 0 : 1)));
    if (row.rev)  row.rev.value  = Math.min(1, Math.max(0, (parseFloat(row.rev.value)||0.1)));
  });
}

const qaSwitchDrumsBtn = document.getElementById('qaSwitchDrums');
if (qaSwitchDrumsBtn) qaSwitchDrumsBtn.addEventListener('click', switchDrumTypes);
const drmSwitchBtn = document.getElementById('drmSwitch');
if (drmSwitchBtn) drmSwitchBtn.addEventListener('click', switchDrumTypes);


// === Auto trigger change melody when last-bar improv is engaged ===
const autoLastBarCb = document.getElementById('autoLastBarImprov');
function triggerMelodyChange(){
  // Prefer the dedicated button if present
  const btn = document.getElementById('melRnd') || document.getElementById('qaRndMel') || document.getElementById('tRndMel');
  if (btn) { btn.click(); return; }
  // Fallback: if there is a function melRnd() in scope, call it
  try{ if (typeof melRnd === 'function') melRnd(); }catch(e){}
}

// Small scheduler shim: when measure counter is one bar before change, do a one-bar improv
// This relies on existing variables: autoOn, autoMeasures, measureCount, etc.
(function(){
  const origAdvance = (window.__advanceStep || null);
  // We'll intercept the section where measureCount increments if we can find the global tick.
  // If not available, we attach to the main animation frame via nextNoteTime guard.
  let lastBarScheduled = false;
  function maybeScheduleLastBar(){
    if (!autoLastBarCb?.checked) { lastBarScheduled = false; return; }
    if (!autoOn?.checked) { lastBarScheduled = false; return; }
    const bars = parseInt(autoMeasures?.value || '2');
    // If we're one bar before the change boundary, schedule a one-bar improv (mel+bass)
    if ((measureCount % bars) === (bars - 1)) {
      if (!lastBarScheduled){
        // Randomize melody + bass for the next bar
        triggerMelodyChange();
        const rb = document.getElementById('bassRnd') || document.getElementById('qaRndBass') || document.getElementById('tRndBass');
        if (rb) rb.click();
        lastBarScheduled = true;
      }
    } else {
      lastBarScheduled = false;
    }
  }

  // Try to hook into the main scheduler loop by wrapping requestAnimationFrame scheduling of steps.
  const _raf = window.requestAnimationFrame;
  window.requestAnimationFrame = function(fn){
    return _raf.call(window, function(time){
      try{ maybeScheduleLastBar(); }catch(e){}
      return fn(time);
    });
  };
})();

})();</script>
<!-- END MERGE PATCH -->
<!-- END MERGE PATCH -->
<!-- PATCH: Make Second Lead (Lead B) audible by mirroring Lead playback -->
<script>
(function(){
  const $ = (s,r=document)=>r.querySelector(s);

  function getCtx(){ return window.ctx || window.audioCtx || null; }

  // Read Lead B UI state (works with several common id names)
  function leadBEnabled(){
    const ids=['leadBOn','layerLeadB','lead2On','leadBEnable','leadBEnabled'];
    for (const id of ids){ const el=document.getElementById(id); if (el) return !!el.checked; }
    // If no explicit toggle, assume enabled if thereâ€™s a â€œLead Bâ€ section in the UI
    return !!(Array.from(document.querySelectorAll('legend')).some(l=>/lead\s*b/i.test(l.textContent||'')));
  }
  function leadBVol(){
    const ids=['leadBVol','lead2Vol','volLeadB'];
    for (const id of ids){ const el=document.getElementById(id); if (el) return Math.max(0, parseFloat(el.value||'0.8')); }
    return 0.8;
  }
  function leadBTranspose(){
    const ids=['leadBTranspose','leadBInterval','lead2Interval'];
    for (const id of ids){ const el=document.getElementById(id); if (el) return parseInt(el.value)||0; }
    return 0; // unison by default
  }
  function leadBInst(){
    const ids=['leadBInst','lead2Inst'];
    for (const id of ids){ const el=document.getElementById(id); if (el) return (el.value||'square'); }
    return 'square';
  }
  function oscTypeFor(inst){
    switch((inst||'').toLowerCase()){
      case 'saw': case 'supersaw': return 'sawtooth';
      case 'triangle': return 'triangle';
      case 'pwm': case 'square': case 'chipsq': return 'square';
      default: return 'sawtooth';
    }
  }
  const stToRatio = st => Math.pow(2, (st||0)/12);

  function playLeadBWithFreq(f, t, gate, vol){
    const ctx = getCtx(); if (!ctx) return;
    const out = (typeof window.voiceOut === 'function') ? window.voiceOut() : new GainNode(ctx,{gain:1});
    const type = oscTypeFor(leadBInst());
    const o = new OscillatorNode(ctx, {type, frequency: f});
    const g = new GainNode(ctx, {gain: 0});
    // let the filter envelope (envGain) see the voice chain for cutoff sweeps
    g.gain._owner = out;
    o.connect(g).connect(out);

    if (typeof window.envGain === 'function'){
      window.envGain(g.gain, t, gate, 0.004, 0.06, 0.35, vol);
    } else {
      // fallback amp envelope
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.8*vol, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + Math.max(gate, 0.08));
    }

    o.start(t);
    o.stop(t + gate + 0.1);
  }

  // Mirror the primary lead into Lead B without touching your scheduler
  if (typeof window.playLead === 'function' && !window.__leadBPatched){
    const __orig = window.playLead;
    window.playLead = function(f, t, gate){
      const res = __orig.apply(this, arguments);
      try{
        if (leadBEnabled()){
          const vol = leadBVol();
          if (vol > 0.0001){
            const st = leadBTranspose();
            const f2 = f * stToRatio(st);
            // small gate change so unison doesnâ€™t phase-cancel perfectly
            playLeadBWithFreq(f2, t, gate*0.96, vol);
          }
        }
      }catch(e){}
      return res;
    };
    window.__leadBPatched = true;
    console.log('[LeadB Patch] Second lead mirroring enabled.');
  }

// === Switch Drum Types (preserve patterns) ===
function randomChoice(a){ return a[Math.floor(Math.random()*a.length)]; }
function switchDrumTypes(){
  const kickTypes = ['acoustic','808','clicky'];
  const snrTypes  = ['noise','808','clap'];
  const hatTypes  = ['ch','oh','sh'];
  const prcTypes  = ['clap','tom','cow'];
  if (drumCtrl.kick?.type) drumCtrl.kick.type.value = randomChoice(kickTypes);
  if (drumCtrl.snr?.type)  drumCtrl.snr.type.value  = randomChoice(snrTypes);
  if (drumCtrl.hat?.type)  drumCtrl.hat.type.value  = randomChoice(hatTypes);
  if (drumCtrl.prc?.type)  drumCtrl.prc.type.value  = randomChoice(prcTypes);

  // Tasteful random tweaks to character without silencing
  [drumCtrl.kick, drumCtrl.snr, drumCtrl.hat, drumCtrl.prc].forEach(row => {
    if (!row) return;
    if (row.tune) row.tune.value = (Math.random()*24|0)-12;
    if (row.vol)  row.vol.value  = Math.min(1.2, Math.max(0.55, (parseFloat(row.vol.value)||0.9) * (0.8 + Math.random()*0.4)));
    if (row.dly)  row.dly.value  = Math.min(1, Math.max(0, (parseFloat(row.dly.value)||0) * (Math.random()<0.5? 0 : 1)));
    if (row.rev)  row.rev.value  = Math.min(1, Math.max(0, (parseFloat(row.rev.value)||0.1)));
  });
}

const qaSwitchDrumsBtn = document.getElementById('qaSwitchDrums');
if (qaSwitchDrumsBtn) qaSwitchDrumsBtn.addEventListener('click', switchDrumTypes);
const drmSwitchBtn = document.getElementById('drmSwitch');
if (drmSwitchBtn) drmSwitchBtn.addEventListener('click', switchDrumTypes);


// === Auto trigger change melody when last-bar improv is engaged ===
const autoLastBarCb = document.getElementById('autoLastBarImprov');
function triggerMelodyChange(){
  // Prefer the dedicated button if present
  const btn = document.getElementById('melRnd') || document.getElementById('qaRndMel') || document.getElementById('tRndMel');
  if (btn) { btn.click(); return; }
  // Fallback: if there is a function melRnd() in scope, call it
  try{ if (typeof melRnd === 'function') melRnd(); }catch(e){}
}

// Small scheduler shim: when measure counter is one bar before change, do a one-bar improv
// This relies on existing variables: autoOn, autoMeasures, measureCount, etc.
(function(){
  const origAdvance = (window.__advanceStep || null);
  // We'll intercept the section where measureCount increments if we can find the global tick.
  // If not available, we attach to the main animation frame via nextNoteTime guard.
  let lastBarScheduled = false;
  function maybeScheduleLastBar(){
    if (!autoLastBarCb?.checked) { lastBarScheduled = false; return; }
    if (!autoOn?.checked) { lastBarScheduled = false; return; }
    const bars = parseInt(autoMeasures?.value || '2');
    // If we're one bar before the change boundary, schedule a one-bar improv (mel+bass)
    if ((measureCount % bars) === (bars - 1)) {
      if (!lastBarScheduled){
        // Randomize melody + bass for the next bar
        triggerMelodyChange();
        const rb = document.getElementById('bassRnd') || document.getElementById('qaRndBass') || document.getElementById('tRndBass');
        if (rb) rb.click();
        lastBarScheduled = true;
      }
    } else {
      lastBarScheduled = false;
    }
  }

  // Try to hook into the main scheduler loop by wrapping requestAnimationFrame scheduling of steps.
  const _raf = window.requestAnimationFrame;
  window.requestAnimationFrame = function(fn){
    return _raf.call(window, function(time){
      try{ maybeScheduleLastBar(); }catch(e){}
      return fn(time);
    });
  };
})();

})();
</script>
<!-- END PATCH -->


<!-- PATCH: Robust Envelope Enable/Disable -->
<script>
(function(){
  const $ = (id) => document.getElementById(id);
  function envOn(){
    const el = $('envEnable') || $('fEnvOn');
    return el ? !!el.checked : true;
  }
  if (!window.__ENV_ENABLE_PATCHED__) {
    const origEnvGain = window.envGain;
    // Override envGain to respect envOn()
    window.envGain = function(target, t, dur, a=0.004, d=0.06, s=0.35, vel=1){
      if (!envOn()) {
        // Bypass envelopes: hold a steady level for the note duration
        const level = 0.9 * (vel ?? 1);
        try {
          target.cancelScheduledValues(t - 0.005);
          target.setValueAtTime(level, t - 0.002);
          target.setValueAtTime(level, t + Math.max(dur, 0.001));
        } catch(e) {}
        return;
      }
      if (typeof origEnvGain === 'function') {
        return origEnvGain(target, t, dur, a, d, s, vel);
      }
      // Fallback amplitude env if original is missing
      try {
        const peak = 0.9 * (vel ?? 1);
        target.cancelScheduledValues(t - 0.005);
        target.setValueAtTime(0.0001, t - 0.002);
        target.linearRampToValueAtTime(peak, t + a);
        target.setTargetAtTime(peak * s, t + a, d);
        const relStart = t + Math.max(dur - 0.02, 0);
        target.setTargetAtTime(0.0001, relStart, 0.015);
      } catch(e) {}
    };

    // Nudge voiceOut filter type to 'allpass' when envelopes are off
    if (typeof window.voiceOut === 'function') {
      const origVoiceOut = window.voiceOut;
      window.voiceOut = function(){
        const g = origVoiceOut.apply(this, arguments);
        try {
          const filt = g && (g._filt || g._filter);
          if (filt) {
            const typEl = $('fType');
            const want = envOn() ? (typEl ? typEl.value : 'lowpass') : 'allpass';
            filt.type = want;
          }
        } catch(e) {}
        return g;
      };
    }

    // Update on UI toggle
    const toggle = $('envEnable') || $('fEnvOn');
    if (toggle) {
      toggle.addEventListener('change', () => {
        // No need to touch active voices; new ones will respect the state
        // Optionally update status display if present
        if (window.autoStatus) {
          autoStatus.textContent = envOn() ? 'Envelope: ON' : 'Envelope: OFF';
        }
      });
    }

    window.__ENV_ENABLE_PATCHED__ = true;
  }

// === Switch Drum Types (preserve patterns) ===
function randomChoice(a){ return a[Math.floor(Math.random()*a.length)]; }
function switchDrumTypes(){
  const kickTypes = ['acoustic','808','clicky'];
  const snrTypes  = ['noise','808','clap'];
  const hatTypes  = ['ch','oh','sh'];
  const prcTypes  = ['clap','tom','cow'];
  if (drumCtrl.kick?.type) drumCtrl.kick.type.value = randomChoice(kickTypes);
  if (drumCtrl.snr?.type)  drumCtrl.snr.type.value  = randomChoice(snrTypes);
  if (drumCtrl.hat?.type)  drumCtrl.hat.type.value  = randomChoice(hatTypes);
  if (drumCtrl.prc?.type)  drumCtrl.prc.type.value  = randomChoice(prcTypes);

  // Tasteful random tweaks to character without silencing
  [drumCtrl.kick, drumCtrl.snr, drumCtrl.hat, drumCtrl.prc].forEach(row => {
    if (!row) return;
    if (row.tune) row.tune.value = (Math.random()*24|0)-12;
    if (row.vol)  row.vol.value  = Math.min(1.2, Math.max(0.55, (parseFloat(row.vol.value)||0.9) * (0.8 + Math.random()*0.4)));
    if (row.dly)  row.dly.value  = Math.min(1, Math.max(0, (parseFloat(row.dly.value)||0) * (Math.random()<0.5? 0 : 1)));
    if (row.rev)  row.rev.value  = Math.min(1, Math.max(0, (parseFloat(row.rev.value)||0.1)));
  });
}

const qaSwitchDrumsBtn = document.getElementById('qaSwitchDrums');
if (qaSwitchDrumsBtn) qaSwitchDrumsBtn.addEventListener('click', switchDrumTypes);
const drmSwitchBtn = document.getElementById('drmSwitch');
if (drmSwitchBtn) drmSwitchBtn.addEventListener('click', switchDrumTypes);


// === Auto trigger change melody when last-bar improv is engaged ===
const autoLastBarCb = document.getElementById('autoLastBarImprov');
function triggerMelodyChange(){
  // Prefer the dedicated button if present
  const btn = document.getElementById('melRnd') || document.getElementById('qaRndMel') || document.getElementById('tRndMel');
  if (btn) { btn.click(); return; }
  // Fallback: if there is a function melRnd() in scope, call it
  try{ if (typeof melRnd === 'function') melRnd(); }catch(e){}
}

// Small scheduler shim: when measure counter is one bar before change, do a one-bar improv
// This relies on existing variables: autoOn, autoMeasures, measureCount, etc.
(function(){
  const origAdvance = (window.__advanceStep || null);
  // We'll intercept the section where measureCount increments if we can find the global tick.
  // If not available, we attach to the main animation frame via nextNoteTime guard.
  let lastBarScheduled = false;
  function maybeScheduleLastBar(){
    if (!autoLastBarCb?.checked) { lastBarScheduled = false; return; }
    if (!autoOn?.checked) { lastBarScheduled = false; return; }
    const bars = parseInt(autoMeasures?.value || '2');
    // If we're one bar before the change boundary, schedule a one-bar improv (mel+bass)
    if ((measureCount % bars) === (bars - 1)) {
      if (!lastBarScheduled){
        // Randomize melody + bass for the next bar
        triggerMelodyChange();
        const rb = document.getElementById('bassRnd') || document.getElementById('qaRndBass') || document.getElementById('tRndBass');
        if (rb) rb.click();
        lastBarScheduled = true;
      }
    } else {
      lastBarScheduled = false;
    }
  }

  // Try to hook into the main scheduler loop by wrapping requestAnimationFrame scheduling of steps.
  const _raf = window.requestAnimationFrame;
  window.requestAnimationFrame = function(fn){
    return _raf.call(window, function(time){
      try{ maybeScheduleLastBar(); }catch(e){}
      return fn(time);
    });
  };
})();

})();
</script>

</body>
</html>
